-- TODO (general):
-- * Almost all SDL calls can fail, this library should check
--    all these calls and do something about it.
-- * Review implicit conversions and try to optimize that
-- * Also review integer sizes, should I use uinteger,
--    usize, or smalled fixed sizes like int32?
-- * Change the "ok, errmsg, result" return pattern to an more lua-like "ok, err_msg"
--   -> for that, create a new "option" library which you replace the "optional" library from Rotor
--      (this will be used while the official optional nelua feature is not implemented)
-- * Abstract used SDL symbols, like SDL_Scancode, used in get_key method
-- * Create a good color palette, I may create a second extra code with even more
--    color definitions, like 'nene.html-palette', 'nene.raylib-palette', etc.

require 'sdl2'
require 'sdl2_image'
require 'sdl2_mixer'

require 'math'
require 'vector'

require 'gamemath'

global Nene = @record{}

local prev_music_id: usize = 0

global Nene.Color = @record{
  r: uint8,
  g: uint8,
  b: uint8,
  a: uint8,
}

-- Some handy colors
global Nene.Palette:record{
  BLACK: Nene.Color,
  WHITE: Nene.Color,
  RED: Nene.Color,
  GREEN: Nene.Color,
  BLUE: Nene.Color,
  YELLOW: Nene.Color,
  BG: Nene.Color,
} = {
  { 0x00, 0x00, 0x00, 0xff },
  { 0xff, 0xff, 0xff, 0xff },
  { 0xff, 0x00, 0x00, 0xff },
  { 0x00, 0xff, 0x00, 0xff },
  { 0x00, 0x00, 0xff, 0xff },
  { 0xfc, 0xea, 0x20, 0xff },
  { 0x69, 0x46, 0x6b, 0xff }
}

global Nene.Sound = @record{
  _data: *Mix_Chunk,
  channel: integer, -- -1 when no channel is being used
}

-- plays the sound
-- when `true` is passed as argument, the sound will loop forever;
-- when a integer is passed as a argument, the sound will loop `loop` times
function Nene.Sound:play(loop: overload(boolean, integer, niltype))
  check(self._data ~= nilptr, 'play: Cannot play a nilptr sound')
  local loops = 0

  ## if loop.type.is_boolean then
    loops = loop and -1 or 0
  ## elseif loop.type.is_integral then
    loops = ĺoop
  ## end

  self.channel = Mix_PlayChannel(-1, self._data, loops)
end

-- stops the sound
function Nene.Sound:stop()
  if self.channel >= 0 then
    Mix_HaltChannel(self.channel)
    self.channel = -1
  end
end

-- free the sound's memory, is recommended to first stop the sound, use `stop_and_free` instead
function Nene.Sound:free()
  check(self._data ~= nilptr, 'free: cannot free a nilptr sound')
  Mix_FreeChunk(self._data)
  self._data = nilptr
end

-- stops and free the sound's memory
function Nene.Sound:stop_and_free()
  self:stop()
  self:free()
end

global Nene.Music = @record{
  _data: *Mix_Music,
  id: usize,
}

function Nene.Music:free()
  Mix_FreeMusic(self._data)
  self._data = nilptr
end

-- TODO:
global Nene.Camera = @record{b: byte}

-- just a wrap of SDL_Texture, the `_data` field
-- should never be directly accessed, instead, use
-- the methods, which do checks
global Nene.Texture = @record{
  _data: *SDL_Texture,
  width: uinteger,
  height: uinteger,
}

-- create a new initialized texture, always either use this or `Nene.CoreState.load_texture`
function Nene.Texture.new(new_tex: *SDL_Texture): Nene.Texture
  check(new_tex ~= nilptr, "Cannot initialize Nene.Texture with a nilptr")

  local fmt: uint32, access: cint, w: cint, h: cint;
  local ok = SDL_QueryTexture(new_tex, &fmt, &access, &w, &h)

  local new: Nene.Texture = {
    _data = new_tex,
    width = w,
    height = h,
  }
  return new
end

function Nene.Texture:get(): *SDL_Texture
  check(self ~= nilptr, 'Texture is nilptr')
  check(self._data ~= nilptr, "Texture doesn't points to any loaded resource")
  return self._data
end

-- I may move this to a general "free" function of Nene
-- which could decide the right free procedure at compile-time
function Nene.Texture:free()
  check(self._data ~= nilptr, "There is no texture to be freed")
  SDL_DestroyTexture(self._data)
  self._data = nilptr
end

-- a texture atlas just contains a pointer to a texture
-- and the information about individual sub-textures
-- the texture atlas in Nene is used just like
-- as a tile set, in other words, all sub-textures of this
-- atlas contains the same size and are uniformly aligned
global Nene.TextureAtlas = @record{
  texture: *Nene.Texture,
  unit_width: uinteger,
  unit_height: uinteger
}

-- Animation range type, used on Spritesheets
global Nene.AnimationRange = @record{
  name: stringview,
  fps: number,
  from: usize,
  to: usize,
}

function Nene.AnimationRange.__eq(l: Nene.AnimationRange, r: Nene.AnimationRange): boolean
  return (
    l.from == r.from and
    l.to == r.to and
    l.fps == r.fps and
    l.name == r.name
  )
end

-- a sprite sheet uses an atlas and applies it for sprites
-- it contains an atlas and a sequence of animations ranges.
global Nene.SpriteSheet = @record{
  atlas: *Nene.TextureAtlas,
  animations: vector(Nene.AnimationRange)
}

## Nene.value.metafields.SpriteSheet.value.is_spritesheet = true
## Nene.value.metafields.SpriteSheet.value.is_atlas_user = true

-- search the animation range with the respective name
-- when found, it returns `true` and the a copy of the respective animation range,
-- otherwise it returns `false` and a unitilialized animation range.
function Nene.SpriteSheet:get_named_animation_range(name: stringview): (boolean, Nene.AnimationRange)
  for i = 0, < #self.animations do
    if self.animations[i].name == name then
      return true, self.animations[i]
    end
  end

  return false, (@Nene.AnimationRange){}
end

-- a tilemap uses an atlas and applies it for tilemaps:
-- it contains just two fields:
-- * atlas field (read above)
-- * a map, this map is a vector of integers,
--   0 and positive numbers refers to the indexes of the atlas,
--   while negative numbers is a "skip" count, which skips
--   some tiles of the tilemap, this should be used on empty
--   space tiles (like the space of a room);
global Nene.Tilemap = @record{
  atlas: *Nene.TextureAtlas,
  width: uinteger,
  height: uinteger,
  map: vector(isize),
}

function Nene.Tilemap:get_position_from_index(index: usize): GameMath.Vec2
  return (@GameMath.Vec2){
    x = (index % self.width) * self.atlas.unit_width,
    y = (index // self.width) * self.atlas.unit_height
  }
end

## Nene.value.metafields.Tilemap.value.is_tilemap = true
## Nene.value.metafields.Tilemap.value.is_atlas_user = true

-- instead of a internal state, the state is
-- exported and should be used externally.
-- Also, great part of the SDL API only works after initialization
--  so, the ideia is that a CoreState lives just as the SDL
--  after initialization and before quit.
-- SDL functions that should be only used after initialization
--  should be abstracted as a CoreState method, the functions
-- that doesn't contains this limitation should be a Nene
--  function instead.
-- This is something that needs to be reviewed too.
global Nene.CoreState = @record{
  initialized: boolean,
  quit: boolean,
  window: *SDL_Window,
  renderer: *SDL_Renderer,
  keyboard_state: span(uint8),
  current_music: Nene.Music,
}

local CoreState: type = Nene.CoreState

-- try to initialize and return a new initilized
-- core state.
-- returns:
--   * a boolean that indicates true on success
--   * a string error message on failure (or empty otherwise)
--   * a new state, only filled on success
-- notes:
--   You always should first check if the initialization
--   succeeded before trying to use the state
function Nene.init(
  title: stringview,
  pos_x: integer, pos_y: integer,
  size_x: integer, size_y: integer,
  flags: uint32
): (boolean, stringview, Nene.CoreState)
  local new_state: Nene.CoreState = {}

  local sdl_init_result = SDL_Init(SDL_INIT_VIDEO)
  if sdl_init_result < 0 then
    return false, SDL_GetError(), new_state
  end

  local window = SDL_CreateWindow(title, pos_x, pos_y, size_x, size_y, flags)
  if not window then
    return false, SDL_GetError(), new_state
  end

  local renderer = SDL_CreateRenderer(window, -1, SDL_RENDERER_ACCELERATED | SDL_RENDERER_PRESENTVSYNC)
  if not renderer then
    return false, SDL_GetError(), new_state
  end

  local img_init_result = IMG_Init(IMG_INIT_PNG) & IMG_INIT_PNG
  if img_init_result == 0 then
    return false, IMG_GetError(), (@Nene.CoreState){}
  end

  local mixer_init_result = Mix_Init(MIX_INIT_OGG) & MIX_INIT_OGG
  if mixer_init_result == 0 then
    return false, Mix_GetError(), (@Nene.CoreState){}
  end

  local mix_openaudio = Mix_OpenAudio(MIX_DEFAULT_FREQUENCY, MIX_DEFAULT_FORMAT, 2, 2048)
  if mix_openaudio < 0 then
    return false, Mix_GetError(), (@Nene.CoreState){}
  end

  SDL_SetRenderDrawColor(renderer, 0xff, 0xff, 0xff, 0xff)

  new_state = {
    initialized = true,
    quit = false,
    =window,
    =renderer,
  }

  return true, "", new_state
end

-- plays a music
-- when `true` is passed as argument, the music will loop forever;
-- when a integer is passed as a argument, the music will loop `loop` times
function Nene.CoreState:play_music(music: Nene.Music, loop: overload(boolean, integer, niltype))
  check(music._data ~= nilptr, 'play: Cannot play a nilptr music')
  local loops = 0

  ## if loop.type.is_boolean then
    loops = loop and -1 or 0
  ## elseif loop.type.is_integral then
    loops = ĺoop
  ## end

  if Mix_PlayMusic(music._data, loops) == 0 then
    self.current_music = music
  else
    self.current_music = {}
  end
end

-- stops the music
function Nene.CoreState:stop_music()
  Mix_HaltMusic()
end

function CoreState:terminate()
  check(self.initialized, 'Core State variable is not initialized')

  self.initialized = false

  SDL_DestroyRenderer(self.renderer)
  self.renderer = nilptr

  SDL_DestroyWindow(self.window)
  self.window = nilptr

  Mix_CloseAudio()
  Mix_Quit()

  IMG_Quit()

  SDL_Quit()
end

function CoreState:pool_events(evt_callbacks: facultative(record{
  window_cb  : function(window  : SDL_WindowEvent),           -- window window event data
  key_cb     : function(key     : SDL_KeyboardEvent),         -- key keyboard event data
  edit_cb    : function(edit    : SDL_TextEditingEvent),      -- edit text editing event data
  text_cb    : function(text    : SDL_TextInputEvent),        -- text text input event data
  motion_cb  : function(motion  : SDL_MouseMotionEvent),      -- motion mouse motion event data
  button_cb  : function(button  : SDL_MouseButtonEvent),      -- button mouse button event data
  wheel_cb   : function(wheel   : SDL_MouseWheelEvent),       -- wheel mouse wheel event data
  jaxis_cb   : function(jaxis   : SDL_JoyAxisEvent),          -- jaxis joystick axis event data
  jball_cb   : function(jball   : SDL_JoyBallEvent),          -- jball joystick ball event data
  jhat_cb    : function(jhat    : SDL_JoyHatEvent),           -- jhat joystick hat event data
  jbutton_cb : function(jbutton : SDL_JoyButtonEvent),        -- jbutton joystick button event data
  jdevice_cb : function(jdevice : SDL_JoyDeviceEvent),        -- jdevice joystick device event data
  caxis_cb   : function(caxis   : SDL_ControllerAxisEvent),   -- caxis game controller axis event data
  cbutton_cb : function(cbutton : SDL_ControllerButtonEvent), -- cbutton game controller button event data
  cdevice_cb : function(cdevice : SDL_ControllerDeviceEvent), -- cdevice game controller device event data
  adevice_cb : function(adevice : SDL_AudioDeviceEvent),      -- adevice audio device event data (>= SDL 2.0.4)
  quit_cb    : function(quit    : SDL_QuitEvent),             -- quit quit request event data
  user_cb    : function(user    : SDL_UserEvent),             -- user custom event data
  syswm_cb   : function(syswm   : SDL_SysWMEvent),            -- syswm system dependent window event data
  tfinger_cb : function(tfinger : SDL_TouchFingerEvent),      -- tfinger touch finger event data
  mgesture_cb: function(mgesture: SDL_MultiGestureEvent),     -- mgesture multi finger gesture data
  dgesture_cb: function(dgesture: SDL_DollarGestureEvent)     -- dgesture multi finger gesture data
}))
  check(self.initialized, 'Core State variable is not initialized')

  local evt: SDL_Event;

  while SDL_PollEvent(&evt) == 1 do
    if evt.type == SDL_QUIT	 then
      self.quit = true
    end

    ## if not evt_callbacks.type.is_niltype then
      -- TODO: I could use `switch` here
      -- TODO: I think I could just use `if x then` instead of `if x ~= nilptr then` too

      if evt.type == SDL_QUIT and evt_callbacks.quit_cb ~= nilptr then
        evt_callbacks.quit_cb(evt.quit)
      elseif (evt.type == SDL_CONTROLLERAXISMOTION) and evt_callbacks.caxis_cb ~= nilptr then
        evt_callbacks.caxis_cb(evt.caxis)
      elseif (evt.type == SDL_CONTROLLERBUTTONDOWN or evt.type == SDL_CONTROLLERBUTTONUP) and evt_callbacks.cbutton_cb ~= nilptr then
        evt_callbacks.cbutton_cb(evt.cbutton)
      elseif (evt.type == SDL_CONTROLLERDEVICEADDED or evt.type == SDL_CONTROLLERDEVICEREMOVED or evt.type == SDL_CONTROLLERDEVICEREMAPPED) and evt_callbacks.cdevice_cb ~= nilptr then
        evt_callbacks.cdevice_cb(evt.cdevice)
      elseif (evt.type == SDL_DOLLARGESTURE or evt.type == SDL_DOLLARRECORD) and evt_callbacks.dgesture_cb ~= nilptr then
        evt_callbacks.dgesture_cb(evt.dgesture)
      elseif (evt.type == SDL_DROPFILE or evt.type == SDL_DROPTEXT or evt.type == SDL_DROPBEGIN or evt.type == SDL_DROPCOMPLETE) and evt_callbacks.drop_cb ~= nilptr then
        evt_callbacks.drop_cb(evt.drop)
      elseif (evt.type == SDL_FINGERMOTION or evt.type == SDL_FINGERDOWN or evt.type == SDL_FINGERUP) and evt_callbacks.tfinger_cb ~= nilptr then
        evt_callbacks.tfinger_cb(evt.tfinger)
      elseif (evt.type == SDL_KEYDOWN or evt.type == SDL_KEYUP) and evt_callbacks.key_cb ~= nilptr then
        evt_callbacks.key_cb(evt.key)
      elseif (evt.type == SDL_JOYAXISMOTION) and evt_callbacks.jaxis_cb ~= nilptr then
        evt_callbacks.jaxis_cb(evt.jaxis)
      elseif (evt.type == SDL_JOYBALLMOTION) and evt_callbacks.jball_cb ~= nilptr then
        evt_callbacks.jball_cb(evt.jball)
      elseif (evt.type == SDL_JOYHATMOTION) and evt_callbacks.jhat_cb ~= nilptr then
        evt_callbacks.jhat_cb(evt.jhat)
      elseif (evt.type == SDL_JOYBUTTONDOWN or evt.type == SDL_JOYBUTTONUP) and evt_callbacks.jbutton_cb ~= nilptr then
        evt_callbacks.jbutton_cb(evt.jbutton)
      elseif (evt.type == SDL_JOYDEVICEADDED or evt.type == SDL_JOYDEVICEREMOVED) and evt_callbacks.jdevice_cb ~= nilptr then
        evt_callbacks.jdevice_cb(evt.jdevice)
      elseif (evt.type == SDL_MOUSEMOTION) and evt_callbacks.motion_cb ~= nilptr then
        evt_callbacks.motion_cb(evt.motion)
      elseif (evt.type == SDL_MOUSEBUTTONDOWN or evt.type == SDL_MOUSEBUTTONUP) and evt_callbacks.button_cb ~= nilptr then
        evt_callbacks.button_cb(evt.button)
      elseif (evt.type == SDL_MOUSEWHEEL) and evt_callbacks.wheel_cb ~= nilptr then
        evt_callbacks.wheel_cb(evt.wheel)
      elseif (evt.type == SDL_MULTIGESTURE) and evt_callbacks.mgesture_cb ~= nilptr then
        evt_callbacks.mgesture_cb(evt.mgesture)
      elseif (evt.type == SDL_SYSWMEVENT) and evt_callbacks.syswm_cb ~= nilptr then
        evt_callbacks.syswm_cb(evt.syswm)
      elseif (evt.type == SDL_TEXTEDITING) and evt_callbacks.edit_cb ~= nilptr then
        evt_callbacks.edit_cb(evt.edit)
      elseif (evt.type == SDL_TEXTINPUT) and evt_callbacks.text_cb ~= nilptr then
        evt_callbacks.text_cb(evt.text)
      elseif (evt.type == SDL_USEREVENT) and evt_callbacks.user_cb ~= nilptr then
        evt_callbacks.user_cb(evt.user)
      elseif (evt.type == SDL_WINDOWEVENT) and evt_callbacks.window_cb ~= nilptr then
        evt_callbacks.window_cb(evt.window)
      elseif (evt.type == SDL_AUDIODEVICEADDED or evt.type == SDL_AUDIODEVICEREMOVED) and _callbacks.adevice_cb ~= nilptr then
        evt_callbacks.adevice_cb(evt.adevice)
      end
    ## end
  end

  do -- update keyboard_state
    local kb_state_len: cint;
    local kb_state_arr = SDL_GetKeyboardState(&kb_state_len)

    self.keyboard_state = {
      data = kb_state_arr,
      size = kb_state_len
    }
  end
end

function CoreState:get_key(scancode: SDL_Scancode): boolean
  return self.keyboard_state[scancode] == 1
end

-- try to load a sound from a file
-- it returns:
-- * a boolean that indicates the success or failure of procedure
-- * an error message stringview, it will be an empty string on success
-- * the sound, properly initialized on success
function Nene.CoreState:load_sound(filename: stringview): (boolean, stringview, Nene.Sound)
  local new_sound: Nene.Sound = {
    _data = Mix_LoadWAV(filename),
    channel = -1
  }

  if not new_sound._data then
    return false, Mix_GetError(), new_sound
  else
    return true, '', new_sound
  end
end

-- try to load a music from a file
-- it returns:
-- * a boolean that indicates the success or failure of procedure
-- * an error message stringview, it will be an empty string on success
-- * the music, properly initialized on success
function Nene.CoreState:load_music(filename: stringview): (boolean, stringview, Nene.Music)
  local new_music: Nene.Music = {
    _data = Mix_LoadMUS(filename),
    id = prev_music_id + 1 -- using an unique id
  }

  prev_music_id = new_music.id

  if not new_music._data then
    return false, Mix_GetError(), new_music
  else
    return true, '', new_music
  end
end

-- try to load a texture from a file
-- it returns:
-- * a boolean that indicates the success or failure of procedure
-- * an error message stringview, it will be a empty string on success
-- * the texture, properly initialized on success
function Nene.CoreState:load_texture(filename: stringview): (boolean, stringview, Nene.Texture)
  check(self.initialized, 'Core State variable is not initialized')

  local surface = IMG_Load(filename)
  if not surface then
    return false, IMG_GetError(), (@Nene.Texture){}
  end

  local texture = SDL_CreateTextureFromSurface(self.renderer, surface)
  SDL_FreeSurface(surface)

  if not texture then
    return false, SDL_GetError(), (@Nene.Texture){}
  end

  return true, "", Nene.Texture.new(texture)
end

-- Draw an `atlas` `frame` at a specific `position` from a `spritesheet`
-- You can also pass a `SpriteSheet` or a `Tilemap` as the `atlas` argument
-- TODO: * add `angle`, `center`, and `flip` facultative parameters and use RenderCopyEx
--       * I'll may need scaling too
--       * use `color`
function CoreState:render_draw_atlas_frame(
  atlas_src: overload(Nene.TextureAtlas, Nene.SpriteSheet, Nene.Tilemap),
  frame: usize,
  position: GameMath.Vec2,
  color: Nene.Color
)
  check(self.initialized, 'Core State variable is not initialized')

  ## if atlas_src.type.is_spritesheet or atlas_src.type.is_tilemap then
    local atlas = atlas_src.atlas
  ## else
    local atlas = atlas_src
  ## end

  check(atlas ~= nilptr, 'atlas is not initialized')
  local atlas_texture = atlas.texture:get()

  local tex_w_units = math.ifloor(atlas.texture.width / atlas.unit_width)

  local src_rect: SDL_Rect = {
    x = (frame % tex_w_units) * atlas.unit_width,
    y = math.ifloor(frame / tex_w_units) * atlas.unit_height,
    w = atlas.unit_width,
    h = atlas.unit_height
  }

  local dest_rect: SDL_Rect = {
    x = math.ifloor(position.x),
    y = math.ifloor(position.y),
    w = atlas.unit_width,
    h = atlas.unit_height,
  }

  if color.g == 0 then
    print('color:', color.r, color.g, color.b)
  end

  SDL_SetTextureColorMod(atlas_texture, color.r, color.g, color.b)
  SDL_RenderCopy(self.renderer, atlas_texture, src_rect, dest_rect)
end

function CoreState:render_draw_tilemap(tilemap: Nene.Tilemap, position: GameMath.Vec2, color: Nene.Color)
  check(self.initialized, 'Core State variable is not initialized')
  check(tilemap.atlas ~= nilptr, "tilemap's atlas is not initialized")

  local i_offset = 0

  for i = 0, < #tilemap.map do
    local frame = tilemap.map[i]

    if frame < 0 then
      i_offset = i_offset - frame - 1 -- frame is negative, so this will increate i_offset
    else
      local tile_pos = tilemap:get_position_from_index(i + i_offset)
      self:render_draw_atlas_frame($tilemap.atlas, frame, tile_pos + position, color)
    end
  end
end

function CoreState:render_clear(color: Nene.Color)
  check(self.initialized, 'Core State variable is not initialized')

  SDL_SetRenderDrawColor(self.renderer, color.r, color.g, color.b, color.a)
  SDL_RenderClear(self.renderer)
end

function CoreState:render_draw_rect(rect: GameMath.Rect, use_lines: boolean, color: Nene.Color)
  check(self.initialized, 'Core State variable is not initialized')

  local sdl_rect: SDL_Rect = {
    x = rect.x, y = rect.y,
    w = rect.w, h = rect.h
  }

  SDL_SetRenderDrawColor(self.renderer, color.r, color.g, color.b, color.a)

  if use_lines then
    SDL_RenderDrawRect(self.renderer, sdl_rect)
  else
    SDL_RenderFillRect(self.renderer, sdl_rect)
  end
end

function Nene.get_ms_time()
  return SDL_GetTicks()
end

function CoreState:render_present()
  check(self.initialized, 'Core State variable is not initialized')

  SDL_RenderPresent(self.renderer)
end
