require 'math'

global Math = @record{}

global Math.Vec2 = @record{
  x: number,
  y: number
}

local Vec2 = @Math.Vec2
## Vec2.value.is_vec = true
## Vec2.value.is_vec2 = true

function Math.Vec2.__eq(a: Vec2, b: Vec2): boolean
  return a.x == b.x and a.y == b.y
end

function Math.Vec2.__add(a: Vec2, b: Vec2): Vec2
  return (@Vec2){ x = a.x + b.x, y = a.y + b.y }
end

function Math.Vec2.__sub(a: Vec2, b: Vec2): Vec2
  return (@Vec2){ x = a.x - b.x, y = a.y - b.y }
end

function Math.Vec2.__mul(a: overload(Vec2, number), b: overload(Vec2, number)): Vec2
  ## if a.type.is_vec2 and b.type.is_vec2 then -- both are vectors
    return (@Vec2){ x = a.x * b.x, y = a.y * b.y }
  ## elseif a.type.is_arithmetic then -- b is a vector
    return (@Vec2){ x = b.x * a, y = b.y * a }
  ## else
    return (@Vec2){ x = a.x * b, y = a.y * b }
  ## end
end

function Math.Vec2.__div(a: Vec2, b: Vec2): Vec2
  return (@Vec2){ x = a.x / b.x, y = a.y / b.y }
end

function Math.Vec2.__unm(v: Vec2): Vec2
  return (@Vec2){ x = -v.x, y = -v.y }
end

function Math.Vec2.lerp(a: Vec2, b: Vec2, t: number): Vec2
  return (1.0 - t) * a + t * b
end

function Math.Vec2.len_sqr(v: Vec2): number
  return (v.x * v.x) + (v.y * v.y)
end

function Math.Vec2.__len(v: Vec2): number
  return math.sqrt(Vec2.len_sqr(v))
end

function Math.Vec2.dot(a: Vec2, b: Vec2): number
  return a.x * b.x + a.y * b.y
end

function Math.Vec2.normalized(v: Vec2): Vec2
  local result: Vec2;

  local v_len = #v

  if v_len ~= 0.0 then
    result = { x = v.x / v_len, y = v.y / v_len }
  end

  return result
end

## local decl_rect = function(name, T)
  ## staticassert(T.value.is_arithmetic, 'T is not arithmetic')

  local T: type = #[T]#

  global Math.#|name|# = @record{
    x: T,
    y: T,
    w: T,
    h: T
  }

  local RectT = @Math.#|name|#

  function RectT.is_intersecting(self: RectT, other: overload(RectT, Vec2)): boolean
    ## if other.type.is_vec2 then -- other is Vec2
      return (
        other.x >= self.x and
        other.x <= self.x + self.w and
        other.y >= self.y and
        other.y <= self.y + self.h
      )
    ## else -- then other is is RectT
      return not (
        ( self.x +  self.w) < other.x or -- is `self `on left of `other`? if so, is not intersecting
        (other.x + other.w) <  self.x or -- is `other` on left of `self`? if so, is not intersecting
        ( self.y +  self.h) < other.y or -- is `self `on top of `other`? if so, is not intersecting
        (other.y + other.h) <  self.y    -- is `other` on top of `self`? if so, is not intersecting
      )
    ## end
  end

  function RectT.get_intersection(a: RectT, b: RectT): (RectT, boolean)
    if not a:is_intersecting(b) then
      return (@RectT)(), false
    end

    local max_px = math.max(a.x, b.x)
    local max_py = math.max(a.y, b.y)
    local min_xw = math.min(a.x + a.w, b.x + b.w)
    local min_yh = math.min(a.y + a.h, b.y + b.h)

    local pmin: Vec2 = { max_px, max_py }
    local pmax: Vec2 = { min_xw, min_yh }

    local intersection: RectT = {
      x = pmin.x, y = pmin.y,
      w = math.abs(pmax.x - pmin.x), h = math.abs(pmax.y - pmin.y)
    }

    return intersection, true
  end

  function RectT.get_center(self: RectT): Vec2
    return (@Vec2){
      x = self.x + (self.w / 2),
      y = self.y + (self.h / 2),
    }
  end

  -- a very simple collision resolution, it returns a rectangle result from the resolution,
  -- it may be improved on future releases.
  --
  -- It returns:
  -- * a boolean which contains if the two rectangles were really intersecting
  -- * a new rectangle with the collision resolved
  function RectT.simple_collision(self: RectT, intersected: RectT): (boolean, RectT)
    local function resolve_vertical(result: RectT, self: RectT, self_center: Vec2, intersected: RectT, intersected_center: Vec2): (RectT)
      if self_center.y < intersected_center.y then -- go to top
        result.y = intersected.y - self.h
      else -- go to bottom
        result.y = intersected.y + intersected.h
      end

      return result
    end

    local function resolve_horizontal(result: RectT, self: RectT, self_center: Vec2, intersected: RectT, intersected_center: Vec2): (RectT)
      if self_center.x < intersected_center.x then -- go to left
        result.x = intersected.x - self.w
      else -- go to right
        result.x = intersected.x + intersected.w
      end

      return result
    end

    local intersection, is_intersecting = self:get_intersection(intersected)

    -- skip if is not actually intersecting
    if not is_intersecting then
      return false, (@RectT)()
    end

    local result = self -- copy self

    local self_center = self:get_center()
    local intersected_center = intersected:get_center()
    local centers_diff = intersected_center - self_center

    if math.abs(centers_diff.y) > math.abs(centers_diff.x) then -- is vertical
      result = resolve_vertical(result, self, self_center, intersected, intersected_center)
    elseif math.abs(centers_diff.x) > math.abs(centers_diff.y) then -- is horizontal
      result = resolve_horizontal(result, self, self_center, intersected, intersected_center)
    else -- is diagonal
      result = resolve_vertical(result, self, self_center, intersected, intersected_center)
      result = resolve_horizontal(result, self, self_center, intersected, intersected_center)
    end

    return true, result
  end

  ## RectT.value.is_rect = true
## end

## decl_rect('Rectf', number)
## decl_rect('Rect', integer)

function Math.Rectf:to_rect(): Math.Rect
  return (@Math.Rect){
    x = math.ifloor(self.x), y = math.ifloor(self.y),
    w = math.ifloor(self.w), h = math.ifloor(self.h)
  }
end

function Math.Rect:to_rectf(): Math.Rectf
  return (@Math.Rectf){
    x = self.x, y = self.y,
    w = self.w, h = self.h
  }
end

-- This record is intended to generate rectangles from an infinite grid.
global Math.Grid = @record{
  cell_size: record{ width: integer, height: integer }, -- size of the rectangles
  gap: record{ x: integer, y: integer } -- gap between rectagles
}
local Grid = @Math.Grid

-- Generates the rectangle from the grid mathematically. Both the first `column` and `row` are `0` and not `1`.
function Math.Grid.gen_rect(grid: Grid, column: integer, row: integer): Math.Rect
  return (@Math.Rect){
    x = grid.cell_size.width * column + grid.gap.x * column,
    y = grid.cell_size.height * row + grid.gap.y * row,
    w = grid.cell_size.width,
    h = grid.cell_size.height,
  }
end

--[[
Returns the the column and row from a `n`th cell, note that this function is 0-indexed (so, the first cell is `0`, not `1`).

Is necessary to also give how many cells fit on a line.
]]
function Math.Grid.get_nth_cell_column_row(n: isize, cells_per_line: isize): (isize, isize)
  check(cells_per_line ~= 0, 'Cannot calculate row and column with 0 cells per line')
  return n % cells_per_line, n // cells_per_line
end
