require 'sdl2'
require 'sdl2_ttf'
require 'sdl2_image'
require 'sdl2_mixer'

require 'span'
require 'string'

require 'nene.core'

require 'nene.colors'
require 'nene.math'

## local macros = {}

## function macros.fn_warn_sdl_error(fn_name, fn_msg)
  ## staticassert(type(fn_name) == 'string', 'macros.fn_warn_sdl_error: the given fn_name is not a string')
  ## staticassert(type(fn_msg) == 'string', 'macros.fn_warn_sdl_error: the given fn_msg is not a string')

  local warn_msg = string.format(#[fn_name..': '..fn_msg..'. (SDL error: %s)']#, SDL_GetError())
  warn(warn_msg)
  warn_msg:destroy()
## end

--- The core state of Nene, it contains pointers made by SDL2, and doesn't requires any other Nene modules (except
--- Nene.Math and Nene.Color).
--- Most of the `Core`'s functions comes from SDL2 actually.
global Nene.Core = @record{
  quit: boolean,           -- `true` when the application will quit, `false` otherwise;
  window: *SDL_Window,     -- reference to the window created on initialization; using more than 1 window is a non-goal for Nene;
  renderer: *SDL_Renderer, -- reference to the window's renderer, created on initialization
  keyboard_state: [(SDL_NUM_SCANCODES)]uint8,      -- holds the state of keyboard in the current frame
  prev_keyboard_state: [(SDL_NUM_SCANCODES)]uint8, -- holds the state of keyboard in the previous frame
}

--- Nene's core must be initialized before used, `check`s are used to enforce this
global Nene.Core.initialized: boolean = false

--- The callbacks that can be passed on `Core:pool_events` method
---
--- Related SDL documentation:
--- * [SDL_Event](https://wiki.libsdl.org/SDL_Event)
global Nene.Core.EventsCallbacks = @record{
  window_cb  : function(window  : SDL_WindowEvent),           -- window window event data
  key_cb     : function(key     : SDL_KeyboardEvent),         -- key keyboard event data
  edit_cb    : function(edit    : SDL_TextEditingEvent),      -- edit text editing event data
  text_cb    : function(text    : SDL_TextInputEvent),        -- text text input event data
  motion_cb  : function(motion  : SDL_MouseMotionEvent),      -- motion mouse motion event data
  button_cb  : function(button  : SDL_MouseButtonEvent),      -- button mouse button event data
  wheel_cb   : function(wheel   : SDL_MouseWheelEvent),       -- wheel mouse wheel event data
  jaxis_cb   : function(jaxis   : SDL_JoyAxisEvent),          -- jaxis joystick axis event data
  jball_cb   : function(jball   : SDL_JoyBallEvent),          -- jball joystick ball event data
  jhat_cb    : function(jhat    : SDL_JoyHatEvent),           -- jhat joystick hat event data
  jbutton_cb : function(jbutton : SDL_JoyButtonEvent),        -- jbutton joystick button event data
  jdevice_cb : function(jdevice : SDL_JoyDeviceEvent),        -- jdevice joystick device event data
  caxis_cb   : function(caxis   : SDL_ControllerAxisEvent),   -- caxis game controller axis event data
  cbutton_cb : function(cbutton : SDL_ControllerButtonEvent), -- cbutton game controller button event data
  cdevice_cb : function(cdevice : SDL_ControllerDeviceEvent), -- cdevice game controller device event data
  adevice_cb : function(adevice : SDL_AudioDeviceEvent),      -- adevice audio device event data (>= SDL 2.0.4)
  quit_cb    : function(quit    : SDL_QuitEvent),             -- quit quit request event data
  user_cb    : function(user    : SDL_UserEvent),             -- user custom event data
  syswm_cb   : function(syswm   : SDL_SysWMEvent),            -- syswm system dependent window event data
  tfinger_cb : function(tfinger : SDL_TouchFingerEvent),      -- tfinger touch finger event data
  mgesture_cb: function(mgesture: SDL_MultiGestureEvent),     -- mgesture multi finger gesture data
  dgesture_cb: function(dgesture: SDL_DollarGestureEvent),    -- dgesture multi finger gesture data
  drop_cb    : function(drop    : SDL_DropEvent)              -- drag and drop event data
}

--- You should call this method at the start of each game loop tick, it:
--- 1. Pools all SDL events;
--- 2. Updates the `self.quit` boolean value, it becomes `true` when the appplication will quit (see SDL_QuitEvent);
--- 3. Calls the respective callbacks if `evt_callbacks` is given.
---
--- Related SDL documentation:
--- * [SDL_PollEvent](https://wiki.libsdl.org/SDL_PollEvent)
--- * [SDL_Event](https://wiki.libsdl.org/SDL_Event)
--- * [SDL_QuitEvent](https://wiki.libsdl.org/SDL_QuitEvent)
function Nene.Core:pool_events(evt_callbacks: facultative(Nene.Core.EventsCallbacks))
  check(Nene.Core.initialized, 'Core State variable is not initialized')

  local evt: SDL_Event;

  do -- update previous frame keyboard state
    for i = 0, < #self.keyboard_state do
      self.prev_keyboard_state[i] = self.keyboard_state[i]
    end
  end

  while SDL_PollEvent(&evt) == 1 do
    if evt.type == SDL_QUIT	 then
      self.quit = true
    end

    ## if not evt_callbacks.type.is_niltype then
      switch evt.type do
        case SDL_QUIT then
          if evt_callbacks.quit_cb then evt_callbacks.quit_cb(evt.quit) end

        case SDL_CONTROLLERAXISMOTION then
          if evt_callbacks.caxis_cb then evt_callbacks.caxis_cb(evt.caxis) end

        case SDL_CONTROLLERBUTTONDOWN, SDL_CONTROLLERBUTTONUP then
          if evt_callbacks.cbutton_cb then evt_callbacks.cbutton_cb(evt.cbutton) end

        case SDL_CONTROLLERDEVICEADDED, SDL_CONTROLLERDEVICEREMOVED, SDL_CONTROLLERDEVICEREMAPPED then
          if evt_callbacks.cdevice_cb then evt_callbacks.cdevice_cb(evt.cdevice) end

        case SDL_DOLLARGESTURE, SDL_DOLLARRECORD then
          if evt_callbacks.dgesture_cb then evt_callbacks.dgesture_cb(evt.dgesture) end

        case SDL_DROPFILE, SDL_DROPTEXT, SDL_DROPBEGIN, SDL_DROPCOMPLETE then
          if evt_callbacks.drop_cb then evt_callbacks.drop_cb(evt.drop) end

        case SDL_FINGERMOTION, SDL_FINGERDOWN, SDL_FINGERUP then
          if evt_callbacks.tfinger_cb then evt_callbacks.tfinger_cb(evt.tfinger) end

        case SDL_KEYDOWN, SDL_KEYUP then
          if evt_callbacks.key_cb then evt_callbacks.key_cb(evt.key) end

        case SDL_JOYAXISMOTION then
          if evt_callbacks.jaxis_cb then evt_callbacks.jaxis_cb(evt.jaxis) end

        case SDL_JOYBALLMOTION then
          if evt_callbacks.jball_cb then evt_callbacks.jball_cb(evt.jball) end

        case SDL_JOYHATMOTION then
          if evt_callbacks.jhat_cb then evt_callbacks.jhat_cb(evt.jhat) end

        case SDL_JOYBUTTONDOWN, SDL_JOYBUTTONUP then
          if evt_callbacks.jbutton_cb then evt_callbacks.jbutton_cb(evt.jbutton) end

        case SDL_JOYDEVICEADDED, SDL_JOYDEVICEREMOVED then
          if evt_callbacks.jdevice_cb then evt_callbacks.jdevice_cb(evt.jdevice) end

        case SDL_MOUSEMOTION then
          if evt_callbacks.motion_cb then evt_callbacks.motion_cb(evt.motion) end

        case SDL_MOUSEBUTTONDOWN, SDL_MOUSEBUTTONUP then
          if evt_callbacks.button_cb then evt_callbacks.button_cb(evt.button) end

        case SDL_MOUSEWHEEL then
          if evt_callbacks.wheel_cb then evt_callbacks.wheel_cb(evt.wheel) end

        case SDL_MULTIGESTURE then
          if evt_callbacks.mgesture_cb then evt_callbacks.mgesture_cb(evt.mgesture) end

        case SDL_SYSWMEVENT then
          if evt_callbacks.syswm_cb then evt_callbacks.syswm_cb(evt.syswm) end

        case SDL_TEXTEDITING then
          if evt_callbacks.edit_cb then evt_callbacks.edit_cb(evt.edit) end

        case SDL_TEXTINPUT then
          if evt_callbacks.text_cb then evt_callbacks.text_cb(evt.text) end

        case SDL_USEREVENT then
          if evt_callbacks.user_cb then evt_callbacks.user_cb(evt.user) end

        case SDL_WINDOWEVENT then
          if evt_callbacks.window_cb then evt_callbacks.window_cb(evt.window) end

        case SDL_AUDIODEVICEADDED, SDL_AUDIODEVICEREMOVED then
          if evt_callbacks.adevice_cb then evt_callbacks.adevice_cb(evt.adevice) end
      end
    ## end
  end

  do -- update current keyboard_state
    local kb_state: span(uint8) = (do
      local kb_state_len: cint;
      local kb_state_arr = SDL_GetKeyboardState(&kb_state_len)

      return (@span(uint8)){
        data = kb_state_arr,
        size = kb_state_len
      }
    end)

    for i = 0, < #kb_state do
      self.keyboard_state = kb_state[i]
    end
  end
end

--- Get the size of the current window.
---
--- Related SDL documentation:
--- * [SDL_GetWindowSize](https://wiki.libsdl.org/SDL_GetWindowSize)
function Nene.Core:get_window_size(): (cint, cint)
  check(Nene.Core.initialized, 'Core State variable is not initialized')

  local ww: cint, wh: cint;
  SDL_GetWindowSize(self.window, &ww, &wh)
  return ww, wh
end

--- get the current time in milliseconds since SDL initialization (done at the `Core.init` method)
---
--- Related SDL documentation:
--- * [SDL_GetTicks](https://wiki.libsdl.org/SDL_GetTicks)
function Nene.Core:ms_since_init()
  check(Nene.Core.initialized, 'Core State variable is not initialized')
  return SDL_GetTicks()
end

--- when only the `scancode` argument is given, it returns the state of that `scancode` (that is, if is currently pressed);
---
--- when `is_down` argument is also given:
---     * if `is_down` is `true`, then it returns if this scancode was just pressed on the current frame (that is, it wasn't pressed on the previous frame);
---     * if `is_down` is `false`, then it returns if this scancode was just released on the current frame (that is, it was pressed on the previous frame, but currently it isn't).
---
--- Related SDL documentation:
--- * [SDL_Scancode](https://wiki.libsdl.org/SDL_Scancode)
--- * [SDL_GetKeyboardState](https://wiki.libsdl.org/SDL_GetKeyboardState)
function Nene.Core:get_scancode(scancode: SDL_Scancode, is_down: facultative(boolean)): boolean
  check(Nene.Core.initialized, 'Core State variable is not initialized')
  check(scancode < SDL_Scancode.SDL_NUM_SCANCODES)

  ## if is_down.type.is_niltype then
    return self.keyboard_state[scancode] == 1
  ## else
    local currently_pressed = self.keyboard_state[scancode] == 1
    local previously_pressed = self.prev_keyboard_state[scancode] == 1

    if is_down.value then
      return currently_pressed and not previously_pressed
    else
      return not currently_pressed and previously_pressed
    end
  ## end
end

--- returns the mouse coordinates relative to window and a bitmask state of mouse buttons.
---
--- Related SDL documentation:
--- * [SDL_GetMouseState](https://wiki.libsdl.org/SDL_GetMouseState)
function Nene.Core:get_mouse_state(): (Nene.Math.Vec2, uint32)
  local x: cint, y: cint;
  local mbuttons = SDL_GetMouseState(&x, &y)
  return (@Nene.Math.Vec2){=x, =y}, mbuttons
end

--- Set rendering draw color
---
--- Related SDL documentation:
--- * [SDL_SetRenderDrawColor](https://wiki.libsdl.org/SDL_SetRenderDrawColor)
function Nene.Core:set_render_draw_color(color: Nene.Color)
  check(Nene.Core.initialized, 'Core State variable is not initialized')

  SDL_SetRenderDrawColor(self.renderer, color.r, color.g, color.b, color.a)
end

--- it clears the rendering target with the given `color`.
---
--- Related SDL documentation:
--- * [SDL_RenderClear](https://wiki.libsdl.org/SDL_RenderClear)
function Nene.Core:render_clear(color: Nene.Color)
  check(Nene.Core.initialized, 'Core State variable is not initialized')

  self:set_render_draw_color(color)

  if SDL_RenderClear(self.renderer) ~= 0 then
    ## macros.fn_warn_sdl_error('Nene.Core.render_clear', 'could not clear the rendering target')
  end
end

--- renders a line from `origin` to `destination` with the given `color`.
---
--- Related SDL documentation:
--- * [SDL_RenderDrawLine](https://wiki.libsdl.org/SDL_RenderDrawLine)
function Nene.Core:render_draw_line(origin: Nene.Math.Vec2, destination: Nene.Math.Vec2, color: Nene.Color)
  check(Nene.Core.initialized, 'Core State variable is not initialized')

  self:set_render_draw_color(color)

  local origin_px: cint, origin_py: cint, dest_px: cint, dest_py: cint = math.ifloor(origin.x),
                                                                         math.ifloor(origin.y),
                                                                         math.ifloor(destination.x),
                                                                         math.ifloor(destination.y)

  if SDL_RenderDrawLine(self.renderer, origin_px, origin_py, dest_px, dest_py) ~= 0 then
    ## macros.fn_warn_sdl_error('Nene.Core.render_draw_line', "could not render a line")
  end
end

--- renders the given `rectangle` with the given `color`; it will be filled if `use_lines` is `false`.
---
--- Related SDL documentation:
--- * [SDL_Rect](https://wiki.libsdl.org/SDL_Rect)
--- * [SDL_RenderDrawRect](https://wiki.libsdl.org/SDL_RenderDrawRect)
--- * [SDL_RenderFillRect](https://wiki.libsdl.org/SDL_RenderFillRect)
function Nene.Core:render_draw_rect(rectangle: Nene.Math.Rect, use_lines: boolean, color: Nene.Color)
  check(Nene.Core.initialized, 'Core State variable is not initialized')

  local sdl_rect: SDL_Rect = {
    x = rectangle.x, y = rectangle.y,
    w = rectangle.w, h = rectangle.h
  }

  self:set_render_draw_color(color)

  if use_lines then
    if SDL_RenderDrawRect(self.renderer, sdl_rect) ~= 0 then
      ## macros.fn_warn_sdl_error('Nene.Core.render_draw_rect', "could not render a rectangle")
    end
  else
    if SDL_RenderFillRect(self.renderer, sdl_rect) ~= 0 then
      ## macros.fn_warn_sdl_error('Nene.Core.render_draw_rect', "could not render a filled rectangle")
    end
  end
end

--- presents the SDL's composed backbuffer (any rendering operation is done on the SDL's backbuffer,
--- this function presents it).
---
--- This also does some modification on the state, preparing it for the next frame.
---
--- Related SDL documentation:
--- * [SDL_RenderPresent](https://wiki.libsdl.org/SDL_RenderPresent)
function Nene.Core:render_present()
  check(Nene.Core.initialized, 'Core State variable is not initialized')
  SDL_RenderPresent(self.renderer)
end

--- try to initialize and return a new initilized core state.
---
--- returns:
---   * a boolean that indicates true on success
---   * a string error message on failure (or empty otherwise)
---   * a new state, only filled on success
--- notes:
---   * You always should first check if the initialization
---   succeeded before trying to use the state
---
--- Related SDL documentation:
--- * [SDL_Init](https://wiki.libsdl.org/SDL_Init)
--- * [SDL_CreateWindow](https://wiki.libsdl.org/SDL_CreateWindow)
--- * [SDL_CreateRenderer](https://wiki.libsdl.org/SDL_CreateRenderer)
--- * [SDL_SetRenderDrawBlendMode](https://wiki.libsdl.org/SDL_SetRenderDrawBlendMode)
--- * [IMG_Init](https://www.libsdl.org/projects/SDL_image/docs/SDL_image_8.html)
--- * [Mix_OpenAudio](https://www.libsdl.org/projects/SDL_mixer/docs/SDL_mixer_11.html)
--- * [TTF_Init](https://libsdl.org/projects/SDL_ttf/docs/SDL_ttf_8.html)
function Nene.init(
  title: string,
  window_size_x: integer, window_size_y: integer,
  pos_x: facultative(integer), pos_y: facultative(integer),
  flags: facultative(uint32)
): (boolean, string, Nene.Core)
  check(Nene.Core.initialized, "Cannot re-initialize Nene")
  check(window_size_x > 0 and window_size_y > 0, 'cannot create a window with `0` as a size parameter')

  local new_state: Nene.Core = {}

  local sdl_init_result = SDL_Init(SDL_INIT_VIDEO)
  if sdl_init_result < 0 then
    return false, SDL_GetError(), new_state
  end

  ## if pos_x.type.is_niltype then
    local pos_x = SDL_WINDOWPOS_UNDEFINED
  ## end
  ## if pos_y.type.is_niltype then
    local pos_y = SDL_WINDOWPOS_UNDEFINED
  ## end
  ## if flags.type.is_niltype then
    local flags = SDL_WINDOW_SHOWN
  ## end

  local window = SDL_CreateWindow(title, pos_x, pos_y, window_size_x, window_size_y, flags)
  if not window then
    return false, SDL_GetError(), new_state
  end

  local renderer = SDL_CreateRenderer(window, -1, SDL_RENDERER_ACCELERATED | SDL_RENDERER_PRESENTVSYNC)
  if not renderer then
    return false, SDL_GetError(), new_state
  end

  local img_init_result = IMG_Init(IMG_INIT_PNG) & IMG_INIT_PNG
  if img_init_result == 0 then
    return false, IMG_GetError(), (@Nene.CoreState){}
  end

  local mix_openaudio = Mix_OpenAudio(MIX_DEFAULT_FREQUENCY, MIX_DEFAULT_FORMAT, 2, 2048)
  if mix_openaudio < 0 then
    return false, Mix_GetError(), (@Nene.CoreState){}
  end

  local mixer_init_result = Mix_Init(MIX_INIT_OGG) & MIX_INIT_OGG
  if mixer_init_result == 0 then
    return false, Mix_GetError(), (@Nene.CoreState){}
  end

  local ttf_init_result = TTF_Init()
  if ttf_init_result < 0 then
    return false, TTF_GetError(), (@Nene.CoreState){}
  end

  SDL_SetRenderDrawColor(renderer, 0xff, 0xff, 0xff, 0xff)
  SDL_SetRenderDrawBlendMode(renderer, SDL_BLENDMODE_BLEND)

  Core.initialized = true

  new_state = {
    =window,
    =renderer,
  }

  return true, "", new_state
end

--- Finalize application and quits all SDL subsystems
---
--- Related SDL documentation:
--- * [SDL_DestroyRenderer](https://wiki.libsdl.org/SDL_DestroyRenderer)
--- * [SDL_DestroyWindow](https://wiki.libsdl.org/SDL_DestroyWindow)
--- * [TTF_Quit](https://libsdl.org/projects/SDL_ttf/docs/SDL_ttf_10.html)
--- * [Mix_Quit](https://www.libsdl.org/projects/SDL_mixer/docs/SDL_mixer_10.html)
--- * [Mix_CloseAudio](https://www.libsdl.org/projects/SDL_mixer/docs/SDL_mixer_12.html)
--- * [IMG_Quit](https://www.libsdl.org/projects/SDL_image/docs/SDL_image_9.html)
--- * [SDL_Quit](https://wiki.libsdl.org/SDL_Quit)
function Nene.Core:terminate()
  check(Nene.Core.initialized, 'Nene is not initialized')
  Nene.Core.initialized = false

  SDL_DestroyRenderer(self.renderer)
  self.renderer = nilptr

  SDL_DestroyWindow(self.window)
  self.window = nilptr

  TTF_Quit()

  Mix_Quit()
  Mix_CloseAudio()

  IMG_Quit()

  SDL_Quit()
end
