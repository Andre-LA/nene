require 'sdl2'

require 'nene.math'

--- just a wrap of SDL_Texture, the `_data` field
--- should never be directly accessed, instead, use
--- the methods, which do checks
global Nene.Texture = @record{
  _data: *SDL_Texture,   -- internal data, don't use it, use methods `get` and `apply_sdltex` instead
  initialized: boolean, -- internal data, used to check if the texture is initialized
  width: uinteger,       -- width in pixels of the texture
  height: uinteger,      -- height in pixels of the texture
}

## local function texture_check_macro(fn_name)
  check(self.initialized, #[fn_name..": Texture isn't initialized"]#)
  check(self._data ~= nilptr, #[fn_name..": Texture is initialized, but it points to a nil pointer"]#)
## end

--- get the internal data
---
--- Related:
--- * [SDL_Texture](https://wiki.libsdl.org/SDL_Texture)
function Nene.Texture:get(): *SDL_Texture
  ## texture_check_macro('Nene.Texture.get')
  return self._data
end

--- free the internal data
function Nene.Texture:destroy()
  ## texture_check_macro('Nene.Texture.destroy')

  SDL_DestroyTexture(self._data)

  self._data = nilptr
  self.initialized = false
end

--- draw the texture with the `color` tint at the `destination` (which can be a position, a rectangle, or `nil` which will draw at the whole screen),
--- you can optionally pass the `source` rectangle if you want to draw a slice of the texture.
--- However, you need pass a `CoreState` since it requires an initialized SDL to work.
function Nene.Texture:draw(nene_state: Nene.Core, color: Nene.Color, source: facultative(Nene.Math.Rect), destination: overload(Nene.Math.Vec2, Nene.Math.Rect, niltype))
  ## texture_check_macro('Nene.Texture.draw')

  local src: *SDL_Rect, dest: *SDL_Rect;

  ## if not source.type.is_niltype then
  local src_rect: SDL_Rect = {x = source.x, y = source.y, w = source.w, h = source.h}
  src = &src_rect
  ## end

  ## if not destination.type.is_niltype and (destination.type.is_vec or destination.type.is_rect) then
    local dest_rect: SDL_Rect = {x = destination.x, y = destination.y, w = self.width, h = self.height}

    ## if destination.type.is_rect then
      dest_rect.w = destination.w
      dest_rect.h = destination.h
    ## end

    dest = &dest_rect
  ## end

  SDL_SetTextureColorMod(self._data, color.r, color.g, color.b)
  SDL_RenderCopy(nene_state.renderer, self._data, src, dest)
end

function Nene.Texture:apply_sdltex(new_tex: *SDL_Texture)
  if self.initialized then
    self:destroy()
  end

  local fmt: uint32, access: cint, w: cint, h: cint;
  local ok = SDL_QueryTexture(new_tex, &fmt, &access, &w, &h)

  self._data = new_tex
  self.initialized = true
  self.width = w
  self.height = h
end

function Nene.Texture.new(new_tex: *SDL_Texture): Nene.Texture
  local new: Nene.Texture = {}
  new:apply_sdltex(new_tex)

  return new
end
