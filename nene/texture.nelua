require 'sdl2'

require 'nene.math'
require 'nene.core_state'

--- just a wraps a `pointer(SDL_Texture)`, the `_data` field should never be directly accessed,
--- use methods instead, which do `check`s.
---
--- Related SDL documentation:
--- * [SDL_Texture](https://wiki.libsdl.org/SDL_Texture)
global Nene.Texture = @record{
  _data: *SDL_Texture,  -- internal data, don't use it, use methods `get` and `apply_sdltex` instead
  initialized: boolean, -- internal data, used to check if the texture is initialized
  width: uinteger,      -- width of the texture in pixels
  height: uinteger,     -- height of the texture in pixels
}

## local function texture_check_macro(fn_name)
  check(self.initialized, #[fn_name..": Texture isn't initialized"]#)
  check(self._data ~= nilptr, #[fn_name..": Texture is initialized, but it points to a nil pointer"]#)
## end

--- get the internal data
---
--- Related SDL documentation:
--- * [SDL_Texture](https://wiki.libsdl.org/SDL_Texture)
function Nene.Texture:get(): *SDL_Texture
  ## texture_check_macro('Nene.Texture.get')
  return self._data
end

--- free the internal data
---
--- Related SDL documentation:
--- * [SDL_DestroyTexture](https://wiki.libsdl.org/SDL_DestroyTexture)
function Nene.Texture:destroy()
  ## texture_check_macro('Nene.Texture.destroy')

  SDL_DestroyTexture(self._data)

  self._data = nilptr
  self.initialized = false
end

--- draw the texture with a `color` tint at the `destination` (which can be a position, a rectangle, or `nil` which will draw at the whole screen),
--- you can optionally pass the `source` rectangle if you want to draw a slice of the texture.
--- Note that you need pass an initialized `Nene.Core`.
---
--- Related Nene documentation:
--- * [Nene.Core.set_texture_color_modulation](core_state.md#nenecoreset_texture_color_modulation)
--- * [Nene.Core.render_copy](core_state.md#nenecorerender_copy)
function Nene.Texture:draw(nene_state: Nene.Core, color: Nene.Color, source: facultative(Nene.Math.Rect), destination: overload(Nene.Math.Vec2, Nene.Math.Rect, niltype))
  ## texture_check_macro('Nene.Texture.draw')

  Nene.Core.set_texture_color_modulation(self._data, color)

  ## if not destination.type.is_niltype then
    local dest: Nene.Math.Rect = { x = destination.x, y = destination.y, w = self.width, h = self.height }

    ## if destination.type.is_rect then
      dest.w, dest.h = destination.w, destination.h
    ## end

    nene_state:render_copy(self._data, src, dest)
  ## else
    nene_state:render_copy(self._data, src, nil)
  ## end
end

--- Applies a new internal texture (with a `pointer(SDL_Texture)`).
--- If the texture is initialized, then it will destroy itself before applying this new SDL_Texture.
--- It also updates the information fields (like `width` and `height`).
---
--- Related Nene documentation:
--- * [Nene.Core.query_texture_size](core_state.md#nenecorequery_texture_size)
function Nene.Texture:apply_sdltex(new_tex: *SDL_Texture)
  check(new_tex ~= nilptr, "Can't apply a nil SDL_Texture")

  if self.initialized then
    self:destroy()
  end

  local fmt: uint32, access: cint, w: cint, h: cint;
  local w, h = Nene.Core.query_texture_size(new_tex)

  self._data = new_tex
  self.initialized = true
  self.width = w
  self.height = h
end

--- Returns a `Nene.Texture` with the given `tex` applied.
function Nene.Texture.new(tex: *SDL_Texture): Nene.Texture
  local new: Nene.Texture = {}
  new:apply_sdltex(tex)
  return new
end
