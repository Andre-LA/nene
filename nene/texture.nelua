require 'math'

require 'nene.math'
require 'nene.wrappers.sdl'
require 'nene.core'

local Vec2, Rect = Math.Vec2, Math.Rect

-- Wraps an internal (SDL) Texture
global Texture = @record{
  _data: *SDL_Texture,  -- internal data, don't use it directly, use methods instead
  width: uinteger,      -- width of the texture in pixels
  height: uinteger,     -- height of the texture in pixels
}

--[[
It checks if the internal data is `nilptr` and then returns it.

Related SDL documentation:
* [SDL_Texture](https://wiki.libsdl.org/SDL_Texture)
]]
function Texture:get(): *SDL_Texture
  check(self._data ~= nilptr, 'Texture.get: Texture internal data is `nilptr`')
  return self._data
end

--[[
Free internal data and resets to zeroed state.

Related SDLWrapper documentation:
* [SDLWrapper.destroy_texture](wrappers/sdl.md#sdlwrapperdestroy_texture)
]]
function Texture:destroy()
  local internal_tex = self:get()
  SDLWrapper.destroy_texture(internal_tex)

  self._data = nilptr
  self.width, self.height = 0, 0
end

--[[
Applies a new internal texture (with a `pointer(SDL_Texture)`).

If there is non-`nilptr` internal texture, then it's freed before applying this new internal texture.

It also updates `width` and `height` fields.

Related Nene documentation:
* [SDLWrapper.query_texture_size](wrappers/sdl.md#sdlwrapperquery_texture_size)
* [Texture.destroy](#texturedestroy)
]]
function Texture:apply_sdltex(new_tex: *SDL_Texture)
  check(new_tex ~= nilptr, "Can't apply a nil SDL_Texture")

  if self._data ~= nilptr then
    self:destroy()
  end

  local w: cint, h: cint;
  local w, h = SDLWrapper.query_texture_size(new_tex)

  self._data = new_tex
  self.width = w
  self.height = h
end

--[[
Returns an initialized `Texture` with the given `tex` applied.

Related Nene documentation:
* [Texture.apply_sdltex](#textureapply_sdltex)
]]
function Texture.new(tex: *SDL_Texture): Texture
  local new: Texture = {}
  new:apply_sdltex(tex)
  return new
end

--[[
Creates a `Texture` from `Nene.create_sdl_texture` using the given `access` and `format`.

`format` and `access` are optional.

By default, `format` is SDL_PIXELFORMAT_RGBA8888 and access is `SDL_TEXTUREACCESS_STATIC`.

Related Nene documentation:
* [Nene.create_sdl_texture](core.md#nenecreate_sdl_texture)
]]
function Texture.create_texture(nene: Nene, width: cint, height: cint, format: facultative(SDL_PixelFormatEnum), access: facultative(SDL_TextureAccess)): Texture
  ## if format.type.is_niltype then
  local format = SDL_PIXELFORMAT_RGBA8888
  ## end

  ## if access.type.is_niltype then
  local access = SDL_TEXTUREACCESS_STATIC
  ## end

  local sdl_tex = SDLWrapper.create_texture(nene.renderer, format, access, width, height)
  return Texture.new(sdl_tex)
end

--[[
Loads an image file and returns a Texture and an ok status.

If the operations fails, the ok status will be `false` and uninitialized texture.

Related SDLWrapper documentation:
* [ImgWrapper.img_load](wrappers/img.md#imgwrapperimg_load)
* [SDLWrapper.create_texture_from_surface](wrappers/sdl.md#sdlwrappercreate_texture_from_surface)
* [SDLWrapper.free_surface](wrappers/sdl.md#sdlwrapperfree_surface)
]]
function Texture.load(nene: Nene, filepath: cstring): (Texture, boolean)
  local img_surface, ok = ImgWrapper.img_load(filepath)

  if not ok then
    return (@Texture)(), false
  end

  defer
    SDLWrapper.free_surface(img_surface)
  end

  local sdl_texture, ok = SDLWrapper.create_texture_from_surface(nene.renderer, img_surface)
  if not ok then
    return (@Texture)(), false
  end

  return Texture.new(sdl_texture), true
end

--[[
Draw the texture at the `destination` (which can be a position, a rectangle, or `nil` which will draw at the whole screen),
you can optionally pass the `source` rectangle if you want to draw a slice of the texture.

A `color` tint can be optionally passed, which is white by default.

Related Nene documentation:
* [Color](colors.md#color)
* [SDLWrapper.set_texture_color_modulation](wrappers/sdl.md#sdlwrapperset_texture_color_modulation)
* [Nene.render_copy](core.md#nenerender_copy)
* [Math.Rect](math.md#mathrect)
* [Math.Vec2](math.md#mathvec2)
]]
function Texture:draw(nene: Nene, color: facultative(Color), source: facultative(Rect), destination: overload(Vec2, Rect, niltype))
  ## if color.type.is_niltype then
  local color = Color.Palette.white
  ## end

  local internal_tex = self:get()

  ## if destination.type.is_vec then -- shadow the vec2 destination with a rect destination
  local destination: Rect = { x = destination.x, y = destination.y, w = self.width, h = self.height }
  ## end

  SDLWrapper.set_texture_color_modulation(internal_tex, color)
  nene:render_copy(internal_tex, source, destination)
end
