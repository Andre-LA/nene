-- The Texture module.

-- Copyright (c) 2021-2022 Andr√© Luiz Alvares
-- Nene is licensed under the Zlib license.
-- Please refer to the LICENSE file for details
-- SPDX-License-Identifier: Zlib

local math = require 'math'

local Nene = require 'nene'
local Vec2 = require 'nene.math.vec2'
local Rect = require 'nene.math.rect'
local Color = require 'nene.color'

require 'nene.macros'
## local warn_msg = macros.warn_msg

require 'nene.raw.sdl2'

--[[
Wraps an internal (SDL2) Texture

Related SDL documentation:
  * [SDL_Texture](https://wiki.libsdl.org/SDL_Texture)
  * [SDL_PixelFormatEnum](https://wiki.libsdl.org/SDL_PixelFormatEnum)
  * [SDL_TextureAccess](https://wiki.libsdl.org/SDL_TextureAccess)
]]
local Texture = @record{
  _data: *SDL_Texture,         -- internal data, don't use it directly, use methods instead
  width: cint,                 -- width of the texture in pixels
  height: cint,                -- height of the texture in pixels
  format: Nene.PixelFormat,    -- texture pixel format
  access: SDL_TextureAccess,   -- texture access pattern, you can use Texture.Access type
}

--[[
_"An enumeration of texture access patterns"_

It's a copy of SDL_TextureAccess enum, see below:

Related SDL documentation:
  * [SDL_TextureAccess](https://wiki.libsdl.org/SDL_TextureAccess)
]]
local Texture.Access = @enum(cint){
  Static = SDL_TEXTUREACCESS_STATIC,
  Streaming = SDL_TEXTUREACCESS_STREAMING,
  Target = SDL_TEXTUREACCESS_TARGET,
}

--[[
_"An enumeration of the texture channel modulation used in SDL_RenderCopy()."_

It's a copy of SDL_TextureModulate enum, see below:

Related SDL documentation:
  * [SDL_TextureModulate](https://wiki.libsdl.org/SDL_TextureModulate)
]]
local Texture.Modulate = @enum(cint) {
  None = SDL_TEXTUREMODULATE_NONE,
  Color = SDL_TEXTUREMODULATE_COLOR,
  Alpha = SDL_TEXTUREMODULATE_ALPHA,
}

--[[
Returns the `pointer(SDL_Texture)` internal data.

It also [`check`](https://nelua.io/libraries/#check)s if the internal data is `nilptr`.

Related SDL documentation:
* [SDL_Texture](https://wiki.libsdl.org/SDL_Texture)
]]
function Texture:get_raw(): *SDL_Texture
  check(self._data ~= nilptr, 'Texture.get: Texture internal data is `nilptr`')
  return self._data
end

--[[
Free internal data and resets to zeroed state.

Related SDL2 documentation:
* [SDL_DestroyTexture](https://wiki.libsdl.org/SDL_DestroyTexture)
]]
function Texture:destroy()
  local internal_tex = self:get_raw()
  SDL_DestroyTexture(internal_tex)
  $self = (@Texture)()
end

-- Effectively the same as `destroy`, called when a to-be-closed variable goes out of scope.
function Texture:__close()
  self:destroy()
end

--[[
Applies a new internal texture (with a `pointer(SDL_Texture)`).

If there is non-`nilptr` internal texture, then it's freed before applying this new internal texture.

It also updates `width`, `height`, `format` and `access` fields.

Returns an `ok` status with `true` value if the texture query is successful.

Related Nene documentation:
* [Texture.destroy](#texturedestroy)

Related SDL documentation:
* [SDL_QueryTexture](https://wiki.libsdl.org/SDL_QueryTexture)
]]
function Texture:apply_raw(new_tex: *SDL_Texture): (boolean)
  check(new_tex ~= nilptr, "Can't apply a nilptr SDL_Texture")

  if self._data ~= nilptr then
    self:destroy()
  end

  local fmt: uint32, access: cint, w: cint, h: cint;

  if SDL_QueryTexture(new_tex, &fmt, &access, &w, &h) ~= 0 then
    warn_msg!('Texture.apply_raw', 'failed to query applied texture')
    return true
  end

  self._data, self.width, self.height, self.format, self.access = new_tex, w, h, fmt, access

  return false
end

--[[
Returns an initialized `Texture` with the given `raw_tex` applied.

Related Nene documentation:
* [Texture.apply_raw](#textureapply_raw)
]]
function Texture.init(raw_tex: *SDL_Texture): Texture
  local new: Texture = {}
  new:apply_raw(raw_tex)
  return new
end

--[[
Creates a `Texture` using the given `access` and `format`.

`format` and `access` are optional.

By default, `format` is SDL_PIXELFORMAT_RGBA8888 and access is `SDL_TEXTUREACCESS_STATIC`.

Related Nene documentation:
* [Nene.create_raw_texture](init.md#nenecreate_raw_texture)

Related SDL2 documentation:
* [SDL_PixelFormatEnum](https://wiki.libsdl.org/SDL_PixelFormatEnum)
* [SDL_TextureAccess](https://wiki.libsdl.org/SDL_TextureAccess)
* [SDL_CreateTexture](https://wiki.libsdl.org/SDL_CreateTexture)
]]
function Texture.create_texture(width: cint, height: cint, format: facultative(Nene.PixelFormat), access: facultative(Texture.Access)): (boolean, Texture)
  local nene: *Nene = Nene.instance()

  ## if format.type.is_niltype then
  local format: Nene.PixelFormat = Nene.PixelFormat.RGBA8888
  ## end

  ## if access.type.is_niltype then
  local access: Texture.Access = Texture.Access.Static
  ## end

  local ok, raw_texture = nene:create_raw_texture(format, access, width, height)

  if not ok then
    return false, (@Texture)()
  end

  return true, Texture.init(raw_texture)
end

--[[
Loads an image file and returns an ok status and a `Texture` from the loaded image.

Returns an `ok` status with `true` value and the created texture if successful.

If the operations fails, a warning is sent and return will be a `false` ok status and an uninitialized texture.

Related SDL2 documentation:
* [IMG_Load](https://www.libsdl.org/projects/SDL_image/docs/SDL_image_11.html)
* [SDL_CreateTextureFromSurface](https://wiki.libsdl.org/SDL_CreateTextureFromSurface)
* [SDL_FreeSurface](https://wiki.libsdl.org/SDL_FreeSurface)
]]
function Texture.load(filepath: cstring): (boolean, Texture)
  local nene = Nene.instance()

  local raw_surface: *SDL_Surface = IMG_Load(filepath)

  if not raw_surface then
    warn_msg!('Texture.load', 'error while loading image', 'IMG_GetError')
    return false, (@Texture)()
  end

  defer SDL_FreeSurface(raw_surface) end

  local ok, raw_texture = nene:create_raw_texture_from_surface(raw_surface)

  if not raw_texture then
    return false, (@Texture)()
  end

  return true, Texture.init(raw_texture)
end

--[[
Draw the texture at the `destination` (which can be a position, a rectangle, or `nil` which will draw at the whole screen),
you can optionally pass the `source` rectangle if you want to draw a slice of the texture.

A `color` tint can be optionally passed, which is white by default.

Related Nene documentation:
* [Nene.set_raw_texture_color_mod](init.md#neneset_raw_texture_color_mod)
* [Nene.render_copy](init.md#nenerender_copy)
* [Color](color.md#color)
* [Math.Rect](math/rect.md#rect)
* [Math.Vec2](math/vec2.md#vec2)
]]
function Texture:draw(
  color: facultative(Color),
  source: facultative(Rect),
  destination: overload(Vec2, Rect, niltype),
  angle: facultative(number),
  center: facultative(Vec2),
  flip_horizontal: facultative(boolean),
  flip_vertical: facultative(boolean)
)
  local nene: *Nene = Nene.instance()

  ## if color.type.is_niltype then
  local color = Color.Palette.white
  ## end

  ## if destination.type.is_vec2 then -- shadow the vec2 destination with a rect destination
  local destination: Rect = {
    x = math.ifloor(destination.x),
    y = math.ifloor(destination.y),
    w = self.width,
    h = self.height
  }
  ## end

  local raw_tex = self:get_raw()

  if not nene:set_raw_texture_color_mod(raw_tex, color) then
    warn_msg!('Texture.draw', 'could not set the texture color modulation')
  end

  if not nene:render_copy(raw_tex, source, destination, angle, center, flip_horizontal, flip_vertical) then
    warn_msg!('Texture.render_copy', 'could not draw the texture on the rendering target')
  end
end

return Texture
