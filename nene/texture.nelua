require 'nene.math'
require 'nene.wrappers.sdl'
require 'nene.core'

local Vec2, Rect = Math.Vec2, Math.Rect

-- Wraps an internal (SDL) Texture
global Texture = @record{
  _data: *SDL_Texture,  -- internal data, don't use it directly, use methods instead
  width: uinteger,      -- width of the texture in pixels
  height: uinteger,     -- height of the texture in pixels
}

--[[
It checks if the internal data is `nilptr` and then returns it.

Related SDL documentation:
* [SDL_Texture](https://wiki.libsdl.org/SDL_Texture)
]]
function Texture:get(): *SDL_Texture
  check(self._data ~= nilptr, 'Texture.get: Texture internal data is `nilptr`')
  return self._data
end

--[[
Free internal data and resets to zeroed state.

Related SDLWrapper documentation:
* [SDLWrapper.destroy_texture](wrappers/sdl.md#sdlwrapperdestroy_texture)
]]
function Texture:destroy()
  local internal_tex = self:get()
  SDLWrapper.destroy_texture(internal_tex)

  self._data = nilptr
  self.width, self.height = 0, 0
end

--[[
Applies a new internal texture (with a `pointer(SDL_Texture)`).

If there is non-`nilptr` internal texture, then it's freed before applying this new internal texture.

It also updates `width` and `height` fields.

Related Nene documentation:
* [SDLWrapper.query_texture_size](wrappers/sdl.md#sdlwrapperquery_texture_size)
* [Texture.destroy](#texturedestroy)
]]
function Texture:apply_sdltex(new_tex: *SDL_Texture)
  check(new_tex ~= nilptr, "Can't apply a nil SDL_Texture")

  if self._data ~= nilptr then
    self:destroy()
  end

  local w: cint, h: cint;
  local w, h = SDLWrapper.query_texture_size(new_tex)

  self._data = new_tex
  self.width = w
  self.height = h
end

--[[
Returns an initialized `Texture` with the given `tex` applied.

Related Nene documentation:
* [Texture.apply_sdltex](#textureapply_sdltex)
]]
function Texture.new(tex: *SDL_Texture): Texture
  local new: Texture = {}
  new:apply_sdltex(tex)
  return new
end

--[[
Draw the texture at the `destination` (which can be a position, a rectangle, or `nil` which will draw at the whole screen),
you can optionally pass the `source` rectangle if you want to draw a slice of the texture.

A `color` tint can be optionally passed, which is white by default.

Related Nene documentation:
* [Color](colors.md#color)
* [SDLWrapper.set_texture_color_modulation](wrappers/sdl.md#sdlwrapperset_texture_color_modulation)
* [Nene.render_copy](core.md#nenerender_copy)
* [Math.Rect](math.md#mathrect)
* [Math.Vec2](math.md#mathvec2)
]]
function Texture:draw(nene: Nene, color: facultative(Color), source: facultative(Rect), destination: overload(Vec2, Rect, niltype))
  ## if color.type.is_niltype then
  local color = Color.Palette.white
  ## end

  local internal_tex = self:get()

  ## if destination.type.is_vec then -- shadow the vec2 destination with a rect destination
  local destination: Rect = { x = destination.x, y = destination.y, w = self.width, h = self.height }
  ## end

  SDLWrapper.set_texture_color_modulation(internal_tex, color)
  nene:render_copy(internal_tex, source, destination)
end
