-- The Segment module, it represents a "finite line", with an origin and ending

--[[
Copyright (c) 2021-present Andr√© Luiz Alvares
Nene is licensed under the Zlib license.
Please refer to the LICENSE file for details
SPDX-License-Identifier: Zlib
]]

local Vec2 = require 'nene.math.vec2'
local Vec2i = require 'nene.math.vec2i'
local Rect = require 'nene.math.rect'

local Segment = @record{
  origin: Vec2,
  ending: Vec2,
}
## Segment.value.is_segment = true

-- Return the vector of the segment, that is, the ending minus the origin.
function Segment.as_vec2(self: Segment): Vec2
  return self.ending - self.origin
end

-- Returns 4 segments respective to each side of an rectangle.
function Segment.segments_from_rect(rect: Rect): [4]Segment
  -- rp and rs stands for rect position and rect size.
  local rp = rect:get_position():to_vec2()
  local rs = rect:get_size()
  
  local segments: [4]Segment = {
    { origin = {          }, ending = { x = rs.x } }, -- top side
    { origin = { x = rs.x }, ending = { y = rs.y } }, -- right side
    { origin = {          }, ending = { y = rs.y } }, -- left side
    { origin = { y = rs.y }, ending = { x = rs.x } }, -- bottom side
  }

  for i = 0, < #segments do
    segments[i].origin = segments[i].origin + rp
    segments[i].ending = segments[i].origin + segments[i].ending
  end

  return segments
end

--[[
Makes an intersection test with another segment and returns the following values:

* boolean: `true` if there's intersection, `false` otherwise;
* boolean: `true` if both segments are parallel, note that there's no intersection when segments are parallel;
* Vec2   : the intersection point, if no intersection is found then it's a zeroed Vec2;
* number : the scalar of `self` that would intersect `other`, when there's no intersection, the value will be out of the [0, 1] interval;
* number : the scalar of `other` that would intersect `self`, when there's no intersection, the value will be out of the [0, 1] interval.
]]
function Segment.get_segment_intersection(self: Segment, other: Segment): (boolean, boolean, Vec2, number, number)
  -- reference: https://www.youtube.com/watch?v=5FkOO1Wwb8w
  
  local ab: Vec2 = self:as_vec2()
  local cd: Vec2 = other:as_vec2()

  local ab_x_cd = ab:cross(cd)

  if ab_x_cd == 0.0 then
    return false, true
  end
    
  local point: Vec2
  
  local ac: Vec2 = Segment.as_vec2({ origin = self.origin, ending = other.origin })
  local t1: number = ac:cross(cd) / ab_x_cd
  local t2: number = -ab:cross(ac) / ab_x_cd
  
  local is_intersecting = 0.0 <= t1 and t1 <= 1.0 and 0.0 <= t2 and t2 <= 1.0
  
  if is_intersecting then
   point = self.origin + ab * t1
  end
  
  return is_intersecting, false, point, t1, t2
end

--[[
Makes an intersection test with an rectangle, returns the following values:

* boolean: `true` if there's intersection, `false` otherwise;
* integer: The count of intersections, since an segment can intersects two rectangle edges.
* [2]Vec2: The points of intersections, when there's not intersection on a point, then it's zeroed.
]]
function Segment.get_rect_intersections(self: Segment, other: Rect): (boolean, integer, [2]Vec2)  
  local points: [2]Vec2
  local i_count: byte -- intersections count
  
  local rect_segments = Segment.segments_from_rect(other)

  for i = 0, < #rect_segments do
    local seg_intersected, _, point = self:get_segment_intersection(rect_segments[i])
    if seg_intersected then
      points[i_count] = point
      i_count = i_count + 1
      if i_count == #points then
        break
      end
    end
  end

  return i_count > 0, i_count, points
end

function Segment.is_intersecting(self: Segment, other: overload(Segment, Rect)): boolean
  ## if other.type.is_segment then
    return (self:get_segment_intersection(other))
  ## elseif other.type.is_rect then
    return (self:get_rect_intersections(other))
  ## end
end

return Segment
