-- The Segment module, it represents a "finite line", with an origin and ending

--[[
Copyright (c) 2021-present Andr√© Luiz Alvares
Nene is licensed under the Zlib license.
Please refer to the LICENSE file for details
SPDX-License-Identifier: Zlib
]]

local Vec2 = require 'nene.math.vec2'
local Vec2i = require 'nene.math.vec2i'
local Rect = require 'nene.math.rect'
local Intersections = require 'nene.intersections'

local Segment = @record{
  origin: Vec2,
  ending: Vec2,
}
## Segment.value.is_segment = true

-- Return the vector of the segment, that is, the ending minus the origin.
function Segment.as_vec2(self: Segment): Vec2
  return self.ending - self.origin
end

-- Returns 4 segments respective to each side of an rectangle.
function Segment.segments_from_rect(rect: Rect): [4]Segment
  -- rp and rs stands for rect position and rect size.
  local rp = Vec2.from_Vec2i(rect.pos)
  local rs = rect.size
  
  local segments: [4]Segment = {
    { origin = { x = rs.x            }, ending = { x = rs.x, y = -rs.y } },  -- right side
    { origin = {                     }, ending = { x = rs.x            } },   -- top side
    { origin = {           y = -rs.y }, ending = {                     } },  -- left side
    { origin = { x = rs.x, y = -rs.y }, ending = {           y = -rs.y } }, -- bottom side
  }

  for i = 0, < #segments do
    segments[i].origin = segments[i].origin + rp
    segments[i].ending = segments[i].ending + rp
  end

  return segments
end

--[[
Makes an intersection test with another segment and returns the following values:

* boolean: `true` if there's intersection, `false` otherwise;
* boolean: `true` if both segments are parallel, note that there's no intersection when segments are parallel;
* Vec2   : the intersection point, if no intersection is found then it's a zeroed Vec2;
* number : the scalar of `self` that would intersect `other`, when there's no intersection, the value will be out of the [0, 1] interval;
* number : the scalar of `other` that would intersect `self`, when there's no intersection, the value will be out of the [0, 1] interval.
]]
function Segment.get_segment_intersection(self: Segment, other: Segment): (boolean, boolean, Vec2, number, number)
  -- reference: https://www.youtube.com/watch?v=5FkOO1Wwb8w
  
  local ab: Vec2 = self:as_vec2()
  local cd: Vec2 = other:as_vec2()

  local ab_x_cd = ab:cross(cd)

  if ab_x_cd == 0.0 then
    return false, true
  end
    
  local point: Vec2
  
  local ac: Vec2 = Segment.as_vec2({ origin = self.origin, ending = other.origin })
  local t1: number = ac:cross(cd) / ab_x_cd
  local t2: number = -ab:cross(ac) / ab_x_cd
  
  local is_intersecting = 0.0 <= t1 and t1 <= 1.0 and 0.0 <= t2 and t2 <= 1.0
  
  if is_intersecting then
   point = self.origin + ab * t1
  end
  
  return is_intersecting, false, point, t1, t2
end

--[[
Makes an intersection test with an rectangle, returns the following values:

* boolean: `true` if there's intersection, `false` otherwise;
* integer: The count of intersections, since an segment can intersects two rectangle edges.
* [2]Vec2: The points of intersections.
* [2]Segment: The intersected segments of the rectangle, no intersected segments will be zeroed.
]]
function Segment.get_rect_intersections(self: Segment, other: Rect): (boolean, integer, [2]Vec2, [2]Segment)  
  local points: [2]Vec2
  local segments: [2]Segment
  local count: integer
  
  local rect_segments = Segment.segments_from_rect(other)

  for i = 0, < #rect_segments do
    local seg_intersected, _, point = self:get_segment_intersection(rect_segments[i])
    if seg_intersected then
      segments[count] = rect_segments[i]
      points[count] = point
      count = count + 1
      if count == #points then
        break
      end
    end
  end

  if count == 1 then
    if Intersections.is_intersecting_rect_with_point(other, self.origin:to_Vec2i()) then
      points[1] = self.origin
    else
      points[1] = self.ending
    end
  end

  return count > 0, count, points, segments
end

return Segment
