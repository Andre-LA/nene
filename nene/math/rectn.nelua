-- Copyright (c) 2021-2022 Andr√© Luiz Alvares
-- Nene is licensed under the Zlib license.
-- Please refer to the LICENSE file for details
-- SPDX-License-Identifier: Zlib

local Vec2n = require 'nene.math.vec2n'

local Vec2i = require 'nene.math.vec2i'
local Vec2f = require 'nene.math.vec2'

local math = require 'math'

local ov_vec2: type = @overload(Vec2i, Vec2f)


## local make_rect = generalize(function(T)
  ## static_assert(T.is_arithmetic, '%s is not arithmetic', T)

  local T: type = #[T]#

  local RectT: type <nickname(#[ string.format('Rect(%s)', T) ]#)> = @record{
    x: T, y: T, -- position
    w: T, h: T, -- size
  }

  ## RectT.value.subtype = T
  ## RectT.value.is_rect = true

  local Vec2T: type = @Vec2n(T)

  ## local function rect_init(x, y)
    ## static_assert(x.type.is_vec2 and y.type.is_vec2, "rect_init: either x or y isn't Vec2 type")

    ## if T.is_integral and not Vec2T.value.subtype.is_integral then
    local x = math.ifloor(#[x]#)
    local y = math.ifloor(#[y]#)
    ## end

    in RectT{ =x, =y}
  ## end

  -- convert this
  function RectT.to_raw_rect(rect: RectT): SDL_Rect
    ## if not T.is_integral then
      return SDL_Rect{
        x = math.ifloor(rect.x), y = math.ifloor(rect.y),
        w = math.ifloor(rect.w), h = math.ifloor(rect.h)
      }
    ## else
      return SDL_Rect{
        x = rect.x, y = rect.y,
        w = rect.w, h = rect.h
      }
    ## end
  end

  -- Get rect position
  function RectT:get_position(): Vec2T
    return Vec2T{ self.x, self.y }
  end

  -- Get rect size
  function RectT:get_size(): Vec2T
    return Vec2T{ self.w, self.h }
  end

  -- Returns a copy with a new position
  function RectT:with_position(pos: ov_vec2): RectT
    return RectT{
      x = pos.x, y = pos.y,
      w = self.w, h = self.h
    }
  end

  -- Returns a copy with a new size
  function RectT:with_size(size: ov_vec2): RectT
    return RectT{
      x = self.x, y = self.y,
      w = size.x, h = size.y
    }
  end

  -- Creates a Rect from two bi-dimensional vectors
  function RectT.from_vec2(pos: ov_vec2, size: ov_vec2): RectT
    return (@RectT){
      x = math.ifloor(pos.x) , y = math.ifloor(pos.y),
      w = math.ifloor(size.x), h = math.ifloor(size.y)
    }
  end

  -- Test if another rect or point it's intersecting the rect
  function RectT.is_intersecting(self: RectT, other: overload(RectT, ov_vec2)): boolean
    ## if other.type.is_vec2 then -- other is Vec2
      return (
        other.x >= self.x and
        other.x <= self.x + self.w and
        other.y >= self.y and
        other.y <= self.y + self.h
      )
    ## else -- then other it's RectT
      return not (
        ( self.x +  self.w) < other.x or -- is `self `on left of `other`? if so, is not intersecting
        (other.x + other.w) <  self.x or -- is `other` on left of `self`? if so, is not intersecting
        ( self.y +  self.h) < other.y or -- is `self `on top of `other`? if so, is not intersecting
        (other.y + other.h) <  self.y    -- is `other` on top of `self`? if so, is not intersecting
      )
    ## end
  end

  -- Get an intersection rect between two rects and also if the two rects are actually intersecting.
  --
  -- It's not necessary to test if the two rects are intersecting before using this function, just check
  -- the second return value for that.
  function RectT.get_intersection(a: RectT, b: RectT): (RectT, boolean)
    if not a:is_intersecting(b) then
      return (@RectT)(), false
    end

    local max_px = math.max(a.x, b.x)
    local max_py = math.max(a.y, b.y)
    local min_xw = math.min(a.x + a.w, b.x + b.w)
    local min_yh = math.min(a.y + a.h, b.y + b.h)

    local pmin: Vec2T = { max_px, max_py }
    local pmax: Vec2T = { min_xw, min_yh }

    local intersection: RectT = {
      x = pmin.x, y = pmin.y,
      w = math.abs(pmax.x - pmin.x), h = math.abs(pmax.y - pmin.y)
    }

    return intersection, true
  end

  -- get the center of rectangle.
  function RectT.get_center(self: RectT): Vec2T
    return (@Vec2T){
      x = self.x + (self.w / 2),
      y = self.y + (self.h / 2),
    }
  end

  -- a very simple collision resolution, it returns a rectangle result from the resolution,
  -- it may be improved on future releases.
  --
  -- It returns:
  -- * a boolean which contains if the two rectangles were really intersecting
  -- * a new rectangle with the collision resolved
  function RectT.simple_collision(self: RectT, intersected: RectT): (boolean, RectT)
    local function resolve_vertical(result: RectT, self: RectT, self_center: Vec2T, intersected: RectT, intersected_center: Vec2T): (RectT)
      if self_center.y < intersected_center.y then -- go to top
        result.y = intersected.y - self.h
      else -- go to bottom
        result.y = intersected.y + intersected.h
      end

      return result
    end

    local function resolve_horizontal(result: RectT, self: RectT, self_center: Vec2T, intersected: RectT, intersected_center: Vec2T): (RectT)
      if self_center.x < intersected_center.x then -- go to left
        result.x = intersected.x - self.w
      else -- go to right
        result.x = intersected.x + intersected.w
      end

      return result
    end

    local intersection, is_intersecting = self:get_intersection(intersected)

    -- skip if is not actually intersecting
    if not is_intersecting then
      return false, (@RectT)()
    end

    local result = self -- copy self

    local self_center = self:get_center()
    local intersected_center = intersected:get_center()

    if intersection.w > intersection.h then -- is vertical
      result = resolve_vertical(result, self, self_center, intersected, intersected_center)
    elseif intersection.h > intersection.w then -- is horizontal
      result = resolve_horizontal(result, self, self_center, intersected, intersected_center)
    else -- is diagonal
      result = resolve_vertical(result, self, self_center, intersected, intersected_center)
      result = resolve_horizontal(result, self, self_center, intersected, intersected_center)
    end

    return true, result
  end

  ## return RectT
## end)

local Rectn: type = #[make_rect]#
return Rectn
