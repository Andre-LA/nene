local Vec2 = @record{
  x: number,
  y: number
}

## Vec2.value.is_vec = true
## Vec2.value.is_vec2 = true

function Vec2.__eq(a: Vec2, b: Vec2): boolean
  return a.x == b.x and a.y == b.y
end

function Vec2.__add(a: Vec2, b: Vec2): Vec2
  return (@Vec2){ x = a.x + b.x, y = a.y + b.y }
end

function Vec2.__sub(a: Vec2, b: Vec2): Vec2
  return (@Vec2){ x = a.x - b.x, y = a.y - b.y }
end

function Vec2.__mul(a: overload(Vec2, number), b: overload(Vec2, number)): Vec2
  ## if a.type.is_vec2 and b.type.is_vec2 then -- both are vectors
    return (@Vec2){ x = a.x * b.x, y = a.y * b.y }
  ## elseif a.type.is_arithmetic then -- b is a vector
    return (@Vec2){ x = b.x * a, y = b.y * a }
  ## else
    return (@Vec2){ x = a.x * b, y = a.y * b }
  ## end
end

function Vec2.__div(a: Vec2, b: Vec2): Vec2
  return (@Vec2){ x = a.x / b.x, y = a.y / b.y }
end

function Vec2.__unm(v: Vec2): Vec2
  return (@Vec2){ x = -v.x, y = -v.y }
end

function Vec2.lerp(a: Vec2, b: Vec2, t: number): Vec2
  return (1.0 - t) * a + t * b
end

function Vec2.len_sqr(v: Vec2): number
  return (v.x * v.x) + (v.y * v.y)
end

function Vec2.__len(v: Vec2): number
  return math.sqrt(Vec2.len_sqr(v))
end

function Vec2.dot(a: Vec2, b: Vec2): number
  return a.x * b.x + a.y * b.y
end

function Vec2.normalized(v: Vec2): Vec2
  local result: Vec2;

  local v_len = #v

  if v_len ~= 0.0 then
    result = { x = v.x / v_len, y = v.y / v_len }
  end

  return result
end

return Vec2
