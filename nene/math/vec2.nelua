--[[
The `Vec2` module, it implements a 2D vector with `number` components.
> If you need `integer` components, see the `Vec2i` module.
]]

--[[
Copyright (c) 2021-present Andr√© Luiz Alvares
Nene is licensed under the Zlib license.
Please refer to the LICENSE file for details
SPDX-License-Identifier: Zlib
]]

local math = require 'math'

local Vec2 = @record{
  x: number,
  y: number
}

## Vec2.value.is_vec = true
## Vec2.value.is_vec2 = true

function Vec2.zero(): Vec2
  return Vec2{ x = 0.0, y = 0.0 }
end

function Vec2.one(): Vec2
  return Vec2{ x = 1.0, y = 1.0 }
end

function Vec2.__eq(a: Vec2, b: Vec2): boolean
  return a.x == b.x and a.y == b.y
end

function Vec2.__add(a: Vec2, b: Vec2): Vec2
  return Vec2{ x = a.x + b.x, y = a.y + b.y }
end

function Vec2.__sub(a: Vec2, b: Vec2): Vec2
  return Vec2{ x = a.x - b.x, y = a.y - b.y }
end

function Vec2.__mul(a: overload(number, Vec2), b: overload(number, Vec2)): Vec2
  ## static_assert(not (a.type.is_scalar and b.type.is_scalar), 'A Vec2 multiply needs at least one Vec2 value')

  ## if a.type.is_vec2 and b.type.is_vec2 then -- both are vectors
    return Vec2{ x = a.x * b.x, y = a.y * b.y }
  ## elseif a.type.is_arithmetic then -- b is a vector
    return Vec2{ x = b.x * a, y = b.y * a }
  ## else
    return Vec2{ x = a.x * b, y = a.y * b }
  ## end
end

function Vec2.__unm(v: Vec2): Vec2
  return Vec2{ x = -v.x, y = -v.y }
end

function Vec2.lerp(a: Vec2, b: Vec2, t: number): Vec2
  return (1.0 - t) * a + t * b
end

function Vec2.len_sqr(v: Vec2): number
  return v.x * v.x + v.y * v.y
end

function Vec2.__len(v: Vec2): number
  return math.sqrt(Vec2.len_sqr(v))
end

function Vec2.dot(a: Vec2, b: Vec2): number
  return a.x * b.x + a.y * b.y
end

function Vec2.cross(a: Vec2, b: Vec2): number
  -- note: since this is a 2D vector (or z=0), the cross product returns
  -- the magnitude of the cross product vector instead of the vector itself.
  return a.x * b.y - a.y * b.x
end

function Vec2.normalized(v: Vec2): Vec2
  local result: Vec2;
  local v_len = #v

  if v_len ~= 0.0 then
    result = { x = v.x / v_len, y = v.y / v_len }
  end

  return result
end

return Vec2
