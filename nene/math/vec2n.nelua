-- The `Vec2n` module, it implements a Vec2 (a vertor of two dimensions) using `n` type for `x` and `y` components,
-- where `n` is an arithmetic type.

-- Copyright (c) 2021-2022 Andr√© Luiz Alvares
-- Nene is licensed under the Zlib license.
-- Please refer to the LICENSE file for details
-- SPDX-License-Identifier: Zlib

local math = require 'math'

local a_vec2 = #[ concept(function(attr) return attr.type.is_vec2 end) ]#
local an_arithmetic = #[ concept(function(attr) return attr.type.is_arithmetic end) ]#
local a_vec2_or_scalar = #[ concept(function(attr) return attr.type.is_vec2 or attr.type.is_scalar end) ]#

## local make_vec2 = generalize(function(T)
  ## static_assert(T.is_arithmetic, '%s is not arithmetic', T)

  local T: type = #[T]#

  local Vec2n <nickname(#[ string.format('Vec2(%s)', T) ]#)> = @record{
    x: T, y: T
  }

  ## Vec2n.value.subtype = T
  ## Vec2n.value.is_vec = true
  ## Vec2n.value.is_vec2 = true

  function Vec2n.__eq(a: a_vec2, b: a_vec2): boolean
    return a.x == b.x and a.y == b.y
  end

  function Vec2n.__add(a: a_vec2, b: a_vec2): Vec2n
    return (@Vec2n){ x = a.x + b.x, y = a.y + b.y }
  end

  function Vec2n.__sub(a: a_vec2, b: a_vec2): Vec2n
    return (@Vec2n){ x = a.x - b.x, y = a.y - b.y }
  end

  function Vec2n.__mul(a: a_vec2_or_scalar, b: a_vec2_or_scalar): Vec2n
    ## if a.type.is_vec2 and b.type.is_vec2 then -- both are vectors
      return (@Vec2n){ x = a.x * b.x, y = a.y * b.y }
    ## elseif a.type.is_arithmetic then -- b is a vector
      return (@Vec2n){ x = b.x * a, y = b.y * a }
    ## else
      return (@Vec2n){ x = a.x * b, y = a.y * b }
    ## end
  end

  function Vec2n.__div(a: a_vec2, b: a_vec2): Vec2n
    return (@Vec2n){ x = a.x / b.x, y = a.y / b.y }
  end

  function Vec2n.__unm(v: a_vec2): Vec2n
    return (@Vec2n){ x = -v.x, y = -v.y }
  end

  function Vec2n.lerp(a: a_vec2, b: a_vec2, t: T): Vec2n
    return (1.0 - t) * a + t * b
  end

  function Vec2n.len_sqr(v: a_vec2): T
    return (v.x * v.x) + (v.y * v.y)
  end

  function Vec2n.__len(v: a_vec2): number
    return math.sqrt(Vec2n.len_sqr(v))
  end

  function Vec2n.dot(a: a_vec2, b: a_vec2): T
    return a.x * b.x + a.y * b.y
  end

  ## if not T.is_integral then
  function Vec2n.normalized(v: a_vec2): Vec2n
    local result: Vec2n;

    local v_len = #v

    if v_len ~= 0.0 then
        result = { x = v.x / v_len, y = v.y / v_len }
    end

    return result
  end
  ## end

  ## return Vec2n
## end)

local Vec2n: type = #[make_vec2]#
return Vec2n
