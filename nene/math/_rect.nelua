-- The `Rect` module, it implements a rectangle using `integer` components.

--[[
Copyright (c) 2021-present AndrÃ© Luiz Alvares
Nene is licensed under the Zlib license.
Please refer to the LICENSE file for details
SPDX-License-Identifier: Zlib
]]

local math = require 'math'
local Vec2 = require 'nene.math.vec2'
local Vec2i = require 'nene.math.vec2i'
require 'nene.raw.sdl2'

local Rect = @record{
  x: integer, y: integer, -- position
  w: integer, h: integer, -- size
}
## Rect.value.is_rect = true

## local function as_vec2i(varname, value)
  ## if value.type == Vec2.value then
    local #|varname|# = Vec2.to_Vec2i(#|varname|#)
  ## end
## end

-- convert this to `SDL_Rect`
function Rect.to_raw_rect(rect: Rect): SDL_Rect
  return SDL_Rect{
    x = rect.x, y = rect.y,
    w = rect.w, h = rect.h
  }
end

-- compare this rect with another rect
function Rect.__eq(self: Rect, other: Rect)
  return self.x == other.x and self.y == other.y and self.w == other.w and self.h == other.h
end

-- Get rect position
function Rect.get_position(self: Rect): Vec2i
  return Vec2i{ x = self.x, y = self.y }
end

-- Get rect size
function Rect.get_size(self: Rect): Vec2i
  return Vec2i{ x = self.w, y = self.h }
end

-- Returns a copy with a new position
function Rect.with_position(self: Rect, pos: overload(Vec2i, Vec2)): Rect
  ## as_vec2i('pos', pos)
  return Rect{
    x = pos.x, y = pos.y,
    w = self.w, h = self.h
  }
end

-- Returns a copy with a new position summed with current position
function Rect.add_position(self: Rect, pos: overload(Vec2i, Vec2)): Rect
  ## as_vec2i('pos', pos)
  return self:with_position(self:get_position() + pos)
end

-- Returns a copy with a new size
function Rect.with_size(self: Rect, size: overload(Vec2i, Vec2)): Rect
  ## as_vec2i('size', size)
  return Rect{
    x = self.x, y = self.y,
    w = size.x, h = size.y
  }
end

-- Returns a copy with a new size summed with current size
function Rect.add_size(self: Rect, size: overload(Vec2i, Vec2)): Rect
  ## as_vec2i('size', size)
  return self:with_size(self:get_size() + size)
end

-- Creates a Rect from two bi-dimensional vectors
function Rect.from_vec2(pos: overload(Vec2i, Vec2), size: overload(Vec2i, Vec2)): Rect
  ## as_vec2i('pos', pos)
  ## as_vec2i('size', size)
  return (@Rect){
    x = pos.x, y = pos.y,
    w = size.x, h = size.y
  }
end

-- Test if another rect or point it's intersecting the rect
function Rect.is_intersecting(self: Rect, other: overload(Rect, Vec2i, Vec2)): boolean
  ## if other.type.is_vec2 then -- other is Vec2
    return (
      other.x >= self.x and
      other.x <= self.x + self.w and
      other.y >= self.y and
      other.y <= self.y + self.h
    )
  ## else -- then other it's Rect
    return not (
      ( self.x +  self.w) < other.x or -- is `self `on left of `other`? if so, is not intersecting
      (other.x + other.w) <  self.x or -- is `other` on left of `self`? if so, is not intersecting
      ( self.y +  self.h) < other.y or -- is `self `on top of `other`? if so, is not intersecting
      (other.y + other.h) <  self.y    -- is `other` on top of `self`? if so, is not intersecting
    )
  ## end
end

--[[
Get an intersection rect between two rects and also if the two rects are actually intersecting.

It's not necessary to test if the two rects are intersecting before using this function, just check
the second return value for that.
]]
function Rect.get_intersection(a: Rect, b: Rect): (Rect, boolean)
  if not a:is_intersecting(b) then
    return (@Rect)(), false
  end

  local max_px = math.max(a.x, b.x)
  local max_py = math.max(a.y, b.y)
  local min_xw = math.min(a.x + a.w, b.x + b.w)
  local min_yh = math.min(a.y + a.h, b.y + b.h)

  local pmin: Vec2i = { x = max_px, y = max_py }
  local pmax: Vec2i = { x = min_xw, y = min_yh }

  local intersection: Rect = {
    x = pmin.x, y = pmin.y,
    w = math.abs(pmax.x - pmin.x), h = math.abs(pmax.y - pmin.y)
  }

  return intersection, true
end

-- get the center of rectangle.
function Rect.get_center(self: Rect): Vec2
  return Vec2{
    x = self.x + (self.w / 2),
    y = self.y + (self.h / 2),
  }
end

--[[
A very simple collision resolution.

It returns:
* a boolean which contains if the two rectangles were really intersecting
* a rectangle with the collision resolved
* a rectangle of the intersection between the rectangles
]]
function Rect.simple_collision(self: Rect, intersected: Rect): (boolean, Rect, Rect)
  local function resolve_vertical(result: Rect, self: Rect, self_center: Vec2, intersected: Rect, intersected_center: Vec2): (Rect)
    if self_center.y < intersected_center.y then -- go to top
      result.y = intersected.y - self.h
    else -- go to bottom
      result.y = intersected.y + intersected.h
    end

    return result
  end

  local function resolve_horizontal(result: Rect, self: Rect, self_center: Vec2, intersected: Rect, intersected_center: Vec2): (Rect)
    if self_center.x < intersected_center.x then -- go to left
      result.x = intersected.x - self.w
    else -- go to right
      result.x = intersected.x + intersected.w
    end

    return result
  end

  local intersection, is_intersecting = self:get_intersection(intersected)

  -- skip if is not actually intersecting
  if not is_intersecting then
    return false, (@Rect)()
  end

  local result = self -- copy self

  local self_center = self:get_center()
  local intersected_center = intersected:get_center()

  if intersection.w > intersection.h then -- is vertical
    result = resolve_vertical(result, self, self_center, intersected, intersected_center)
  elseif intersection.h > intersection.w then -- is horizontal
    result = resolve_horizontal(result, self, self_center, intersected, intersected_center)
  else -- is diagonal
    result = resolve_vertical(result, self, self_center, intersected, intersected_center)
    result = resolve_horizontal(result, self, self_center, intersected, intersected_center)
  end

  return true, result, intersection
end

return Rect
