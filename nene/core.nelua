require 'span'

require 'nene.wrappers.sdl'
require 'nene.wrappers.ttf'
require 'nene.wrappers.mix'
require 'nene.wrappers.img'

require 'nene.colors'
require 'nene.math'

local Vec2, Rect = @Math.Vec2, @Math.Rect

local previous_time: uint32 = 0

--[[
The core of Nene, it contains pointers made by SDL2, and doesn't requires any other Nene modules (except
`Math`, `Color` and all SDL wrappers).

Many of the `Core`'s functions wraps wrapper's functions actually.
]]
global Nene = @record{
  quit: boolean,           -- `true` when the application will quit, `false` otherwise;
  delta_time: number,      -- frame's delta time (in seconds!), that is, how much time passed between previous and current frame.
  render_offset: Vec2,     -- rendering offset, this is useful for some basic camera control
  window: *SDL_Window,     -- reference to the window created on initialization; using more than 1 window is a non-goal for Nene;
  renderer: *SDL_Renderer, -- reference to the window's renderer, created on initialization
  keyboard_state: [(SDL_NUM_SCANCODES)]boolean,      -- holds the state of keyboard in the current frame (`true` means "pressed")
  prev_keyboard_state: [(SDL_NUM_SCANCODES)]boolean, -- holds the state of keyboard in the previous frame (`true` means "pressed")
}

--[[
  The initialization state of Nene, it's set to `true` by `Nene.init` and
  set to `false` by `Nene.terminate`, it shouldn't be modified by any other function.
]]
global Nene.initialized = false

--[[
The callbacks that can be passed on `Core:poll_events` method

Related SDL documentation:
* [SDL_Event](https://wiki.libsdl.org/SDL_Event)
]]
global Nene.EventsCallbacks = @record{
  window_cb  : function(window  : SDL_WindowEvent),           -- window window event data
  key_cb     : function(key     : SDL_KeyboardEvent),         -- key keyboard event data
  edit_cb    : function(edit    : SDL_TextEditingEvent),      -- edit text editing event data
  text_cb    : function(text    : SDL_TextInputEvent),        -- text text input event data
  motion_cb  : function(motion  : SDL_MouseMotionEvent),      -- motion mouse motion event data
  button_cb  : function(button  : SDL_MouseButtonEvent),      -- button mouse button event data
  wheel_cb   : function(wheel   : SDL_MouseWheelEvent),       -- wheel mouse wheel event data
  jaxis_cb   : function(jaxis   : SDL_JoyAxisEvent),          -- jaxis joystick axis event data
  jball_cb   : function(jball   : SDL_JoyBallEvent),          -- jball joystick ball event data
  jhat_cb    : function(jhat    : SDL_JoyHatEvent),           -- jhat joystick hat event data
  jbutton_cb : function(jbutton : SDL_JoyButtonEvent),        -- jbutton joystick button event data
  jdevice_cb : function(jdevice : SDL_JoyDeviceEvent),        -- jdevice joystick device event data
  caxis_cb   : function(caxis   : SDL_ControllerAxisEvent),   -- caxis game controller axis event data
  cbutton_cb : function(cbutton : SDL_ControllerButtonEvent), -- cbutton game controller button event data
  cdevice_cb : function(cdevice : SDL_ControllerDeviceEvent), -- cdevice game controller device event data
  adevice_cb : function(adevice : SDL_AudioDeviceEvent),      -- adevice audio device event data (>= SDL 2.0.4)
  quit_cb    : function(quit    : SDL_QuitEvent),             -- quit quit request event data
  user_cb    : function(user    : SDL_UserEvent),             -- user custom event data
  syswm_cb   : function(syswm   : SDL_SysWMEvent),            -- syswm system dependent window event data
  tfinger_cb : function(tfinger : SDL_TouchFingerEvent),      -- tfinger touch finger event data
  mgesture_cb: function(mgesture: SDL_MultiGestureEvent),     -- mgesture multi finger gesture data
  dgesture_cb: function(dgesture: SDL_DollarGestureEvent),    -- dgesture multi finger gesture data
  drop_cb    : function(drop    : SDL_DropEvent)              -- drag and drop event data
}

--[[
You should call this method at the start of each game loop tick, it:
1. Pools all SDL events;
2. Updates the `self.quit` boolean value, it becomes `true` when the appplication will quit (see SDL_QuitEvent);
3. Calls the respective callbacks if `evt_callbacks` is given.

Related SDL documentation:
* [SDL_Event](https://wiki.libsdl.org/SDL_Event)
* [SDL_QuitEvent](https://wiki.libsdl.org/SDL_QuitEvent)
* [SDL_Scancode](https://wiki.libsdl.org/SDL_Scancode)

Related SDLWrapper documentation:
* [SDLWrapper.poll_event](wrappers/sdl.md#sdlwrapperpoll_event)
* [SDLWrapper.get_keyboard_state](wrappers/sdl.md#sdlwrapperget_keyboard_state)
]]
function Nene:poll_events(evt_callbacks: facultative(Nene.EventsCallbacks))
  check(Nene.initialized, 'Nene is not initialized')

  local evt: SDL_Event;

  do -- update previous frame keyboard state
    for i = 0, < #self.keyboard_state do
      self.prev_keyboard_state[i] = self.keyboard_state[i]
    end
  end

  while SDLWrapper.poll_event(evt) do
    if evt.type == SDL_QUIT	then
      self.quit = true
    end

    ## if not evt_callbacks.type.is_niltype then
      switch evt.type do
        case SDL_QUIT then
          if evt_callbacks.quit_cb then evt_callbacks.quit_cb(evt.quit) end

        case SDL_CONTROLLERAXISMOTION then
          if evt_callbacks.caxis_cb then evt_callbacks.caxis_cb(evt.caxis) end

        case SDL_CONTROLLERBUTTONDOWN, SDL_CONTROLLERBUTTONUP then
          if evt_callbacks.cbutton_cb then evt_callbacks.cbutton_cb(evt.cbutton) end

        case SDL_CONTROLLERDEVICEADDED, SDL_CONTROLLERDEVICEREMOVED, SDL_CONTROLLERDEVICEREMAPPED then
          if evt_callbacks.cdevice_cb then evt_callbacks.cdevice_cb(evt.cdevice) end

        case SDL_DOLLARGESTURE, SDL_DOLLARRECORD then
          if evt_callbacks.dgesture_cb then evt_callbacks.dgesture_cb(evt.dgesture) end

        case SDL_DROPFILE, SDL_DROPTEXT, SDL_DROPBEGIN, SDL_DROPCOMPLETE then
          if evt_callbacks.drop_cb then evt_callbacks.drop_cb(evt.drop) end

        case SDL_FINGERMOTION, SDL_FINGERDOWN, SDL_FINGERUP then
          if evt_callbacks.tfinger_cb then evt_callbacks.tfinger_cb(evt.tfinger) end

        case SDL_KEYDOWN, SDL_KEYUP then
          if evt_callbacks.key_cb then evt_callbacks.key_cb(evt.key) end

        case SDL_JOYAXISMOTION then
          if evt_callbacks.jaxis_cb then evt_callbacks.jaxis_cb(evt.jaxis) end

        case SDL_JOYBALLMOTION then
          if evt_callbacks.jball_cb then evt_callbacks.jball_cb(evt.jball) end

        case SDL_JOYHATMOTION then
          if evt_callbacks.jhat_cb then evt_callbacks.jhat_cb(evt.jhat) end

        case SDL_JOYBUTTONDOWN, SDL_JOYBUTTONUP then
          if evt_callbacks.jbutton_cb then evt_callbacks.jbutton_cb(evt.jbutton) end

        case SDL_JOYDEVICEADDED, SDL_JOYDEVICEREMOVED then
          if evt_callbacks.jdevice_cb then evt_callbacks.jdevice_cb(evt.jdevice) end

        case SDL_MOUSEMOTION then
          if evt_callbacks.motion_cb then evt_callbacks.motion_cb(evt.motion) end

        case SDL_MOUSEBUTTONDOWN, SDL_MOUSEBUTTONUP then
          if evt_callbacks.button_cb then evt_callbacks.button_cb(evt.button) end

        case SDL_MOUSEWHEEL then
          if evt_callbacks.wheel_cb then evt_callbacks.wheel_cb(evt.wheel) end

        case SDL_MULTIGESTURE then
          if evt_callbacks.mgesture_cb then evt_callbacks.mgesture_cb(evt.mgesture) end

        case SDL_SYSWMEVENT then
          if evt_callbacks.syswm_cb then evt_callbacks.syswm_cb(evt.syswm) end

        case SDL_TEXTEDITING then
          if evt_callbacks.edit_cb then evt_callbacks.edit_cb(evt.edit) end

        case SDL_TEXTINPUT then
          if evt_callbacks.text_cb then evt_callbacks.text_cb(evt.text) end

        case SDL_USEREVENT then
          if evt_callbacks.user_cb then evt_callbacks.user_cb(evt.user) end

        case SDL_WINDOWEVENT then
          if evt_callbacks.window_cb then evt_callbacks.window_cb(evt.window) end

        case SDL_AUDIODEVICEADDED, SDL_AUDIODEVICEREMOVED then
          if evt_callbacks.adevice_cb then evt_callbacks.adevice_cb(evt.adevice) end
      end
    ## end
  end

  do -- update current keyboard_state
    local kb_state = SDLWrapper.get_keyboard_state()

    for i = 0, < #kb_state do
      self.keyboard_state[i] = kb_state[i] == 1
    end
  end

  -- update delta time
  local current_time = SDLWrapper.get_ticks()
  self.delta_time = (current_time - previous_time) / 1000
  previous_time = current_time
end

--[[
Get the size of the current window.

Related SDLWrapper documentation:
* [SDLWrapper.get_window_size](wrappers/sdl.md#sdlwrapperget_window_size)
]]
function Nene:get_window_size(): (cint, cint)
  check(Nene.initialized, 'Nene is not initialized')

  local w, h = SDLWrapper.get_window_size(self.window)
  return w, h
end

--[[
Returns the state of `scancode`.

* if `is_down` is `true`, then it returns if this scancode was just pressed on the current frame (that is, it wasn't pressed on the previous frame);
* if `is_down` is `false`, then it returns if this scancode was just released on the current frame (that is, it was pressed on the previous frame, but currently it isn't).
* if `is_down` is `nil`, then it returns if is simply currently pressed.

Related SDL documentation:
* [SDL_Scancode](https://wiki.libsdl.org/SDL_Scancode)

Related SDLWrapper documentation:
* [SDLWrapper.get_keyboard_state](wrappers/sdl.md#sdlwrapperget_keyboard_state)
]]
function Nene:get_scancode(scancode: SDL_Scancode, is_down: facultative(boolean)): boolean
  check(Nene.initialized, 'Nene is not initialized')
  check(scancode < SDL_Scancode.SDL_NUM_SCANCODES, 'Invalid scancode')

  ## if is_down.type.is_niltype then
    return self.keyboard_state[scancode]
  ## else
    local currently_pressed = self.keyboard_state[scancode]
    local previously_pressed = self.prev_keyboard_state[scancode]

    if is_down then
      return currently_pressed and not previously_pressed
    else
      return not currently_pressed and previously_pressed
    end
  ## end
end

--[[
Set rendering draw color

Related Nene documentation:
* [Color](colors.md#color)

Related SDL documentation:
* [SDL_Color](https://wiki.libsdl.org/SDL_Color)
* [SDL_Renderer](https://wiki.libsdl.org/SDL_Renderer)

Related SDLWrapper documentation:
* [SDLWrapper.set_render_draw_color](wrappers/sdl.md#sdlwrapperset_render_draw_color)
]]
function Nene:set_render_draw_color(color: Color)
  check(Nene.initialized, 'Nene is not initialized')
  SDLWrapper.set_render_draw_color(self.renderer, color.r, color.g, color.b, color.a)
end

--[[
it clears the rendering target with the given `color`.

Related Nene documentation:
* [Color](colors.md#color)
* [Nene.set_render_draw_color](#neneset_render_draw_color)

Related SDL documentation:
* [SDL_Renderer](https://wiki.libsdl.org/SDL_Renderer)

Related SDLWrapper documentation:
* [SDLWrapper.render_clear](wrappers/sdl.md#sdlwrapperrender_clear)
]]
function Nene:render_clear(color: Color)
  check(Nene.initialized, 'Nene is not initialized')
  self:set_render_draw_color(color)
  SDLWrapper.render_clear(self.renderer)
end

--[[
renders a line from `origin` to `destination` with the given `color`.

Related Nene documentation:
* [Math.Vec2](math.md#mathvec2)
* [Color](colors.md#color)

Related SDLWrapper documentation:
* [SDLWrapper.render_draw_line](wrappers/sdl.md#sdlwrapperrender_draw_line)
]]
function Nene:render_draw_line(origin: Vec2, destination: Vec2, color: facultative(Color))
  ## if color.type.is_niltype then
  local color = Color.Palette.white
  ## end

  check(Nene.initialized, 'Nene is not initialized')

  self:set_render_draw_color(color)

  local origin_px: cint, origin_py: cint, dest_px: cint, dest_py: cint = math.ifloor(origin.x - self.render_offset.x),
                                                                         math.ifloor(origin.y - self.render_offset.y),
                                                                         math.ifloor(destination.x - self.render_offset.x),
                                                                         math.ifloor(destination.y - self.render_offset.y)

  SDLWrapper.render_draw_line(self.renderer, origin_px, origin_py, dest_px, dest_py)
end

--[[
renders the given `rectangle` with the given `color`; it will be filled if `use_lines` is `false`.

Related Nene documentation:
* [Math.Rect](math.md)

Related SDLWrapper documentation:
* [SDLWrapper.render_draw_rect](wrappers/sdl.md#sdlwrapperrender_draw_rect)
* [SDLWrapper.render_fill_rect](wrappers/sdl.md#sdlwrapperrender_fill_rect)
]]
function Nene:render_draw_rect(rectangle: Rect, use_lines: boolean, color: facultative(Color))
  ## if color.type.is_niltype then
  local color = Color.Palette.white
  ## end

  check(Nene.initialized, 'Nene is not initialized')

  local sdl_rect: SDL_Rect = {
    x = math.ifloor(rectangle.x - self.render_offset.x),
    y = math.ifloor(rectangle.y - self.render_offset.y),
    w = rectangle.w,
    h = rectangle.h
  }

  self:set_render_draw_color(color)

  if use_lines then
    SDLWrapper.render_draw_rect(self.renderer, sdl_rect)
  else
    SDLWrapper.render_fill_rect(self.renderer, sdl_rect)
  end
end

--[[
Wrapper of `SDL_RenderCopy`.
Copies `texture` on the rendering target.

By default the whole texture is copied unless the `source` rectangle is given,
in this case only the "source" part of the texture will be copied.

By default the texture will be copied on the whole rendering target unless the `destination` rectangle is given,
in this case it will be copied at this "destination" part of the rendering target.

Related Nene documentation:
* [Math.Rect](math.md)

Related SDL documentation:
* [SDL_Texture](https://wiki.libsdl.org/SDL_Texture)

Related SDLWrapper documentation:
* [SDLWrapper.render_copy](wrappers/sdl.md#sdlwrapperrender_copy)
]]
function Nene:render_copy(texture: *SDL_Texture, source: facultative(Rect), destination: facultative(Rect))
  check(Nene.initialized, 'Nene is not initialized')

  local src: *SDL_Rect, dest: *SDL_Rect;

  ## if not source.type.is_niltype then
  local src_rect: SDL_Rect = {
    x = math.ifloor(source.x),
    y = math.ifloor(source.y),
    w = source.w,
    h = source.h
  }

  src = &src_rect
  ## end

  ## if not destination.type.is_niltype then
  local dest_rect: SDL_Rect = {
    x = math.ifloor(destination.x - self.render_offset.x),
    y = math.ifloor(destination.y - self.render_offset.y),
    w = destination.w,
    h = destination.h
  }

  dest = &dest_rect
  ## end

  SDLWrapper.render_copy(self.renderer, texture, src, dest)
end

--[[
Set a `texture` as rendering target.

If `texture` is not given, then the target will be the window.

Related SDLWrapper documentation:
* [SDLWrapper.set_render_target](wrappers/sdl.md#sdlwrapperset_render_target)
]]
function Nene:set_render_target(texture: facultative(*SDL_Texture))
  check(Nene.initialized, 'Nene is not initialized')

  ## if not texture.type.is_niltype then
    SDLWrapper.set_render_target(self.renderer, texture)
  ## else
    SDLWrapper.set_render_target(self.renderer, nilptr)
  ## end
end

--[[
Wrapper of `SDL_CreateTextureFromSurface`.

Creates a Texture from the given surface.

Related SDL documentation:
* [SDL_Texture](https://wiki.libsdl.org/SDL_Texture)
* [SDL_Surface](https://wiki.libsdl.org/SDL_Surface)

Related SDLWrapper documentation:
* [SDLWrapper.create_texture_from_surface](wrappers/sdl.md#sdlwrappercreate_texture_from_surface)
]]
function Nene:create_texture_from_surface(surface_ref: *SDL_Surface): (*SDL_Texture, boolean)
  check(Nene.initialized, 'Nene is not initialized')
  check(surface_ref ~= nilptr, "cannot create a texture from a nilptr")

  local ok = true
  local texture = SDLWrapper.create_texture_from_surface(self.renderer, surface_ref)

  if not texture then
    ok = false
    warn'Nene.create_texture_from_surface: could not create texture from the given surface'
  end

  return texture, ok
end

--[[
presents the SDL's composed backbuffer (any rendering operation is done on the SDL's backbuffer,
this function presents it).

This also does some modification on the state, preparing it for the next frame.

Related SDLWrapper documentation:
* [SDLWrapper.render_present](wrappers/sdl.md#sdlwrapperrender_present)
]]
function Nene:render_present()
  check(Nene.initialized, 'Nene is not initialized')
  SDLWrapper.render_present(self.renderer)
end

--[[
try to initialize and return a new initilized core state.

returns:
  * a boolean that indicates true on success
  * a new state, only filled on success

notes:
  * You always should first check if the initialization
  succeeded before trying to use the state.

Code example:
```lua
-- initialize nene
local ok, nene = Nene.init('My game title', 1280, 720)

-- test if nene got successfully initialized, here `assert`
-- is used instead of `check`, this way, this test is also done
-- in release mode.
assert(ok, 'error: nene initialization failed')

-- defer nene termination, to release resources used by nene
defer
  nene:terminate()
end
```

Related SDLWrapper documentation:
* [SDLWrapper.sdl_init](wrappers/sdl.md#sdlwrappersdl_init)
* [SDLWrapper.create_window](wrappers/sdl.md#sdlwrappercreate_window)
* [SDLWrapper.create_renderer](wrappers/sdl.md#sdlwrappercreate_renderer)
* [SDLWrapper.set_render_draw_blend_mode](wrappers/sdl.md#sdlwrapperset_render_draw_blend_mode)

Related MixWrapper documentation:
* [MixWrapper.mix_init](wrappers/mix.md#mixwrappermix_init)
* [MixWrapper.open_audio](wrappers/mix.md#mixwrapperopen_audio)

Related ImgWrapper documentation:
* [ImgWrapper.img_init](wrappers/img.md#imgwrapperimg_init)

Related TTFWrapper documentation:
* [TTFWrapper.ttf_init](wrappers/ttf.md#ttfwrapperttf_init)
]]
function Nene.init(
  title: string,
  window_size_x: integer, window_size_y: integer,
  pos_x: facultative(integer), pos_y: facultative(integer),
  flags: facultative(uint32)
): (boolean, Nene)
  check(not Nene.initialized, "Cannot re-initialize Nene")
  check(window_size_x > 0 and window_size_y > 0, 'cannot create a window with `0` as a size parameter')

  -- shadowing arguments with default settings
  ## if pos_x.type.is_niltype then
  local pos_x = SDL_WINDOWPOS_UNDEFINED
  ## end
  ## if pos_y.type.is_niltype then
  local pos_y = SDL_WINDOWPOS_UNDEFINED
  ## end
  ## if flags.type.is_niltype then
  local flags = SDL_WINDOW_SHOWN
  ## end

  local new_state: Nene;

  -- init libraries
  local sdl_init_result = SDLWrapper.sdl_init(SDL_INIT_VIDEO)
  if not sdl_init_result then
    return false, new_state
  end

  local img_init_result = ImgWrapper.img_init(IMG_INIT_PNG)
  if not img_init_result then
    return false, new_state
  end

  local mix_openaudio = MixWrapper.open_audio(MIX_DEFAULT_FREQUENCY, MIX_DEFAULT_FORMAT, 2, 2048)
  if not mix_openaudio then
    return false, new_state
  end

  local mixer_init_result = MixWrapper.mix_init(MIX_INIT_OGG)
  if not mixer_init_result then
    return false, new_state
  end

  local ttf_init_result = TTFWrapper.ttf_init()
  if not ttf_init_result then
    return false, new_state
  end

  -- libraries initialized, so Nene is considered initialized while nothing
  -- go wrong
  Nene.initialized = true

  local window = SDLWrapper.create_window(title, pos_x, pos_y, window_size_x, window_size_y, flags)
  if not window then
    Nene.initialized = false
    return false, new_state
  end

  local renderer = SDLWrapper.create_renderer(window, -1, SDL_RENDERER_ACCELERATED | SDL_RENDERER_PRESENTVSYNC)
  if not renderer then
    Nene.initialized = false
    return false, new_state
  end

  SDLWrapper.set_render_draw_color(renderer, 0xff, 0xff, 0xff, 0xff)
  SDLWrapper.set_render_draw_blend_mode(renderer, SDL_BLENDMODE_BLEND)

  -- everything setup!
  new_state = {
    delta_time = (1 / 60), -- fake delta time targeting 60 fps, this avoids a wrong delta time of 0s.
    =window,
    =renderer,
  }

  return true, new_state
end

--[[
Finalize application and quits all SDL subsystems

Related SDLWrapper documentation:
* [SDLWrapper.destroy_renderer](wrappers/sdl.md#sdlwrapperdestroy_renderer)
* [SDLWrapper.destroy_window](wrappers/sdl.md#sdlwrapperdestroy_window)
* [SDLWrapper.sdl_quit](wrappers/sdl.md#sdlwrapper sdl_quit)

Related ImgWrapper documentation:
* [ImgWrapper.img_quit](wrappers/img.md#imgwrapperimg_quit)

Related TTFWrapper documentation:
* [TTFWrapper.ttf_quit](wrappers/ttf.md#ttfwrapperttf_quit)

Related MixWrapper documentation:
* [MixWrapper.close_audio](wrappers/mix.md#mixwrapperclose_audio)
* [MixWrapper.mix_quit](wrappers/mix.md#mixwrappermix_quit)
]]
function Nene:terminate()
  check(Nene.initialized, 'Nene is not initialized')

  SDLWrapper.destroy_renderer(self.renderer)
  self.renderer = nilptr

  SDLWrapper.destroy_window(self.window)
  self.window = nilptr

  TTFWrapper.ttf_quit()

  MixWrapper.mix_quit()
  MixWrapper.close_audio()

  ImgWrapper.img_quit()

  SDLWrapper.sdl_quit()

  Nene.initialized = false
end
