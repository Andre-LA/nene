local io = require 'io'
local math = require 'math'
local vector = require 'vector'

local Nene = require 'nene'
local Color = require 'nene.color'
local Texture = require 'nene.texture'

local Vec2 = require 'nene.math.vec2'
local Rect = require 'nene.math.rect'
local Grid = require 'nene.math.grid'

--[[
A tilemap contains a `width` number of tiles and a `map` of numbers which are the tiles from the tileset.

This is how `map` "id"s works:
* `map` is a `vector` of `isize` numbers, the first entry is on the uppper-left corner of the tilemap and it goes from
left to right, top to bottom direction.
* each entry is either a tile from the tileset or an empty space.
* when the entry value is `0`, then it's an empty space, othewise it refers to a tile from the tileset (`1` = "1st tile", and so on),
just as tilemap it starts from top-left and goes from left to right, top to bottom.
]]
local Tilemap = @record{
  tilemap_width: isize,
  tileset_width: isize,
  grid: Grid,
  map: vector(isize),
}

-- destroys the internal map vector and set tilemap to zeroed state
function Tilemap:destroy()
  self.map:destroy()

  self.tilemap_width = 0
  self.tileset_width = 0
  self.grid = (@Grid)()
  self.map = (@vector(isize))()
end

-- Effectively the same as `destroy`, called when a to-be-closed variable goes out of scope.
function Tilemap:__close()
  self:destroy()
end

--[[
Gets the proper column and row from a certain tile from the tilemap.

For example, let's say you want to know the column and row of the 9th tile (that is, index `8`) of a tilemap that have a
`width` of 5 tiles:
```lua
-- tilemap grid, the highlighted cell is the 9th tile:
--
--  colums →     0   1   2   3   4
--             ┌───┬───┬───┬───┬───┐
--    rows ↓ 0 │ 0 │ 1 │ 2 │ 3 │ 5 │
--             ├───┼───╬═══╬───┼───┤
--           1 │ 6 │ 7 ║ 8 ║ 9 │10 │
--             └───┴───╩═══╩───┴───┘

-- here we get the column and row of the 9th tile (that is, index 8, since tilemap's map is 0-indexed)
local column, row = my_tilemap:get_tile_column_row(8)
print(column, row) -- prints '2       1'
```

Related Nene documentation:
* [Tilemap.get_tile_pos](#tilemapget_tile_pos)
* [Math.Grid.get_nth_cell_column_row](math.md#mathgridget_nth_cell_column_row)
]]
function Tilemap:get_tile_column_row(index: usize): (isize, isize)
  return Grid.get_nth_cell_column_row(index, self.tilemap_width)
end

--[[
Gets the proper (local) position from a certain tile by column and row of the tilemap (not tileset!).

The column and row of a tile can be obtained through `Tilemap.get_tile_column_row` method.

For example, let's say you want to know the position of the 9th tile (that is, 8th index) of a tilemap that have a
`width` of 5 tiles, 32x32 dimensions each:
```lua
--                   tilemap grid
--
-- columns:    0     1     2     3     4
--          0px   32px  64px  96px  128px
--          ├─────┼─────┼─────┼─────┼─────┬ 0px
--   row: 0 │  0  │  1  │  2  │  3  │  5  │
--          ├─────┼─────@═════╬─────┼─────┼ 32px
--        1 │  6  │  7  ║  8  ║  9  │ 10  │
--          └─────┴─────╩═════╩─────┴─────┴ 64px

-- let's create the above tilemap:
local my_tilemap: Tilemap = {
  tilemap_width =  4, -- here we setup how many tiles fits on a line of the tilemap, the height it's "infinite".
  tileset_width = 10, -- same concept, but on tileset
  -- this comes from the Math module, it stores the "layout" of tilemap and tileset
  grid = {
    cell_size = { 32, 32 } -- the dimensions of each tile, Grid also allows gaps
  },
  map = { -- finally, the map of tilemap, it's just a vector, each entry is the index of tileset
    00, 01, 02, 03,
    10, 11, 12, 13,
  }
}

-- here, we obtain the column and row of the 9th tile using `get_tile_column_row`,
-- since tilemap's map is 0-indexed, we use `8`.
local column, row = my_tilemap:get_tile_column_row(8)

-- returns the position of `@` of the (ascii) grid above, that is, {64, 32}
-- this is the position of the 9th tile relative to `my_tilemap`!
local tile_pos = my_tilemap:get_tile_pos(column, row)
```

Related Nene documentation:
* [Tilemap.get_tile_column_row](#tilemapget_tile_column_row)
* [Math.Vec2](math.md#mathvec2)
* [Math.Grid](math.md#mathgrid)
]]
function Tilemap:get_tile_pos(column: isize, row: isize): Vec2
  return (@Vec2){
    x = column * self.grid.cell_size.width,
    y = row * self.grid.cell_size.height
  }
end

--[[
Returns the map's height.

For example, let's say that an tilemap have 3 tiles of width, and it contains 5 tiles
in it's map, then the map looks like this:

```
┌───┬───┬───┐ ┬ 0
│ 1 │ 2 │ 3 │ │
├───┼───┼───┘ ┼ height
│ 4 │ 5 │     │
└───┴───┘     ┴ 2 --> this is the result
```
]]
function Tilemap.get_height(tilemap: Tilemap): isize
  return math.ceil(#tilemap.map / tilemap.tilemap_width)
end

--[[
Draw the whole `tilemap` using the given `tileset` texture at `position` (relative to screen) using the `color` tint.

A `color` tint can be optionally passed, which is white by default.

Related Nene documentation:
* [Nene](core.md#nene)
* [Math.Grid](math.md#mathgrid)
* [Math.Vec2](math.md#mathvec2)
* [Texture](texture.md#texture)
* [Color](colors.md#color)
]]
function Tilemap.draw(self: Tilemap, tileset: Texture, position: Vec2, color: facultative(Color))
  local nene = Nene.instance()

  ## if color.type.is_niltype then
  local color = Color.Palette.white
  ## end

  for tile_i = 0, < #self.map do
    local tileset_i = self.map[tile_i]

    if tileset_i > 0 then
      local tileset_column, tileset_row = Grid.get_nth_cell_column_row(tileset_i - 1, self.tileset_width)
      local tileset_rect = self.grid:gen_rect(tileset_column, tileset_row)

      local tile_column, tile_row = self:get_tile_column_row(tile_i)
      local tile_pos = self:get_tile_pos(tile_column, tile_row)

      local tile_rect: Rect = {
        x = math.ifloor(position.x + tile_pos.x),
        y = math.ifloor(position.y + tile_pos.y),
        w = tileset_rect.w,
        h = tileset_rect.h,
      }

      tileset:draw(color, tileset_rect, tile_rect)
    end
  end
end

return Tilemap
