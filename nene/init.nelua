-- The core of Nene, this is the main module, which should be initialized and terminated in the same life-cycle as
-- your game.

--[[
Copyright (c) 2021-present Andr√© Luiz Alvares
Nene is licensed under the Zlib license.
Please refer to the LICENSE file for details
SPDX-License-Identifier: Zlib
]]

##if ccinfo.is_emscripten then
  --[[
  This global function is only imported when `is_emscripten` is set, that is, when the emscripten is used to make a web build
  note that the types `integer`, `uinteger` and `number` are also set to be 32-bit.

  Related Emscripten documentation:
  - [emscripten_set_main_loop](https://emscripten.org/docs/api_reference/emscripten.h.html#c.emscripten_set_main_loop)
  ]]
  global function emscripten_set_main_loop(func: function(), fps: cint, simulate_infinite_loop: cint) <cimport,cinclude'<emscripten.h>',nodecl> end

  ##[[
  primtypes.integer = primtypes.int32
  primtypes.uinteger = primtypes.uint32
  primtypes.number = primtypes.float32
  ]]
##end

local span = require 'span'

require 'nene.raw.sdl2'
require 'nene.raw.sdl2_ttf'
require 'nene.raw.sdl2_image'
require 'nene.raw.sdl2_mixer'

## local options = require 'nene.options'

local Color = require 'nene.color'
local Vec2  = require 'nene.math.vec2'
local Rect  = require 'nene.math.rect'
local Rectf = require 'nene.math.rectf'

local gamepad = require 'nene.gamepad'

require 'nene.macros'
## local warn_msg = macros.warn_msg

local GamepadState = @record{
  active: boolean,
  game_controller: *SDL_GameController,
  joystick_id: cint,
  prev_buttons: [SDL_CONTROLLER_BUTTON_MAX]boolean,
  buttons: [SDL_CONTROLLER_BUTTON_MAX]boolean,
}

--[[
The core of Nene, it contains pointers made by SDL2, and doesn't requires any other Nene modules (except
`Math` and `Color`).

Many of the `Core`'s functions wraps SDL's functions actually.
]]
local Nene = @record{
  -- general data
  quit: boolean,        -- `true` when the application will quit, `false` otherwise;
  current_time: uint32, -- time since initialization (in milliseconds!).
  delta_time: number,   -- frame's delta time (in seconds!), that is, how much time passed between previous and current frame.
  render_offset: Vec2,  -- rendering offset, this is useful for some basic camera control

  -- SDL references
  window: *SDL_Window,     -- reference to the window created on initialization; using more than 1 window is a non-goal for Nene;
  renderer: *SDL_Renderer, -- reference to the window's renderer, created on initialization

  -- keyboard state
  keyboard_state: [SDL_NUM_SCANCODES]boolean,      -- store the state of keyboard in the current frame (`true` means "pressed")
  prev_keyboard_state: [SDL_NUM_SCANCODES]boolean, -- store the state of keyboard in the previous frame (`true` means "pressed")

  -- gamepads state
  gamepads_state: [ #[options.gamepad_count]# ]GamepadState, -- store the state of `options.gamepad_count` gamepads

  -- mouse state
  mouse_pos: Vec2,                 -- store the mouse position relative to window
  mouse_relative_motion: Vec2,     -- store the mouse relative motion
  mouse_buttons: [32]boolean,      -- store the mouse buttons state, each index per button (0 is left-button, 1 is middle-button, 2 is right-button)
  prev_mouse_buttons: [32]boolean, -- same as mouse_buttons, but from the previous frame
}

--[[
  The initialization state of Nene, it's set to `true` by `Nene.init` and
  set to `false` by `Nene.terminate`, it shouldn't be modified by any other function.
]]
local Nene.initialized: boolean = false

local instance: Nene;

-- [Check](https://nelua.io/libraries/#check)s if Nene is initialized and then returns the running nene instance.
function Nene.instance(): *Nene
  check(Nene.initialized, 'Nene is not initialized')
  return &instance
end

-- Nene's scancodes, alias of [SDL_Scancode](https://wiki.libsdl.org/SDL_Scancode), for more details, open [scancode's documentation](scancode.md)
local Nene.Scancode: type = require 'nene.scancode'

-- Nene's blend modes, alias of [SDL_BlendMode](https://wiki.libsdl.org/SDL_BlendMode).
local Nene.BlendMode = @enum(cint){
  None    = SDL_BLENDMODE_NONE,
  Blend   = SDL_BLENDMODE_BLEND,
  Add     = SDL_BLENDMODE_ADD,
  Mod     = SDL_BLENDMODE_MOD,
  Mul     = SDL_BLENDMODE_MUL,
  Invalid = SDL_BLENDMODE_INVALID,
}

-- Nene's pixel formats, alias of [SDL_PixelFormatEnum](SDL_PixelFormatEnum).
local Nene.PixelFormat = @enum(cint){
  Unknown = SDL_PIXELFORMAT_UNKNOWN,
  Index1LSB = SDL_PIXELFORMAT_INDEX1LSB,
  Index1MSB = SDL_PIXELFORMAT_INDEX1MSB,
  Index4LSB = SDL_PIXELFORMAT_INDEX4LSB,
  Index4MSB = SDL_PIXELFORMAT_INDEX4MSB,
  Index8 = SDL_PIXELFORMAT_INDEX8,
  RGB332 = SDL_PIXELFORMAT_RGB332,
  XRGB4444 = SDL_PIXELFORMAT_XRGB4444,
  RGB444 = SDL_PIXELFORMAT_RGB444,
  XBGR4444 = SDL_PIXELFORMAT_XBGR4444,
  BGR444 = SDL_PIXELFORMAT_BGR444,
  XRGB1555 = SDL_PIXELFORMAT_XRGB1555,
  RGB555 = SDL_PIXELFORMAT_RGB555,
  XBGR1555 = SDL_PIXELFORMAT_XBGR1555,
  BGR555 = SDL_PIXELFORMAT_BGR555,
  ARGB4444 = SDL_PIXELFORMAT_ARGB4444,
  RGBA4444 = SDL_PIXELFORMAT_RGBA4444,
  ABGR4444 = SDL_PIXELFORMAT_ABGR4444,
  BGRA4444 = SDL_PIXELFORMAT_BGRA4444,
  ARGB1555 = SDL_PIXELFORMAT_ARGB1555,
  RGBA5551 = SDL_PIXELFORMAT_RGBA5551,
  ABGR1555 = SDL_PIXELFORMAT_ABGR1555,
  BGRA5551 = SDL_PIXELFORMAT_BGRA5551,
  RGB565 = SDL_PIXELFORMAT_RGB565,
  BGR565 = SDL_PIXELFORMAT_BGR565,
  RGB24 = SDL_PIXELFORMAT_RGB24,
  BGR24 = SDL_PIXELFORMAT_BGR24,
  XRGB8888 = SDL_PIXELFORMAT_XRGB8888,
  RGB888 = SDL_PIXELFORMAT_RGB888,
  RGBX8888 = SDL_PIXELFORMAT_RGBX8888,
  XBGR8888 = SDL_PIXELFORMAT_XBGR8888,
  BGR888 = SDL_PIXELFORMAT_BGR888,
  BGRX8888 = SDL_PIXELFORMAT_BGRX8888,
  ARGB8888 = SDL_PIXELFORMAT_ARGB8888,
  RGBA8888 = SDL_PIXELFORMAT_RGBA8888,
  ABGR8888 = SDL_PIXELFORMAT_ABGR8888,
  BGRA8888 = SDL_PIXELFORMAT_BGRA8888,
  ARGB2101010 = SDL_PIXELFORMAT_ARGB2101010,
  RGBA32 = SDL_PIXELFORMAT_RGBA32,
  ARGB32 = SDL_PIXELFORMAT_ARGB32,
  BGRA32 = SDL_PIXELFORMAT_BGRA32,
  ABGR32 = SDL_PIXELFORMAT_ABGR32,
  YV12 = SDL_PIXELFORMAT_YV12,
  IYUV = SDL_PIXELFORMAT_IYUV,
  YUY2 = SDL_PIXELFORMAT_YUY2,
  UYVY = SDL_PIXELFORMAT_UYVY,
  YVYU = SDL_PIXELFORMAT_YVYU,
  NV12 = SDL_PIXELFORMAT_NV12,
  NV21 = SDL_PIXELFORMAT_NV21,
  ExternalOES = SDL_PIXELFORMAT_EXTERNAL_OES,
}

--[[
The callbacks that can be passed on `Core:poll_events` method

Related Nene documentation:
- [Nene.poll_events](#nenepoll_events)

Related SDL documentation:
* [SDL_Event](https://wiki.libsdl.org/SDL_Event)
* [SDL_WindowEvent](https://wiki.libsdl.org/SDL_WindowEvent)
* [SDL_KeyboardEvent](https://wiki.libsdl.org/SDL_KeyboardEvent)
* [SDL_TextEditingEvent](https://wiki.libsdl.org/SDL_TextEditingEvent)
* [SDL_TextInputEvent](https://wiki.libsdl.org/SDL_TextInputEvent)
* [SDL_MouseMotionEvent](https://wiki.libsdl.org/SDL_MouseMotionEvent)
* [SDL_MouseButtonEvent](https://wiki.libsdl.org/SDL_MouseButtonEvent)
* [SDL_MouseWheelEvent](https://wiki.libsdl.org/SDL_MouseWheelEvent)
* [SDL_JoyAxisEvent](https://wiki.libsdl.org/SDL_JoyAxisEvent)
* [SDL_JoyBallEvent](https://wiki.libsdl.org/SDL_JoyBallEvent)
* [SDL_JoyHatEvent](https://wiki.libsdl.org/SDL_JoyHatEvent)
* [SDL_JoyButtonEvent](https://wiki.libsdl.org/SDL_JoyButtonEvent)
* [SDL_JoyDeviceEvent](https://wiki.libsdl.org/SDL_JoyDeviceEvent)
* [SDL_ControllerAxisEvent](https://wiki.libsdl.org/SDL_ControllerAxisEvent)
* [SDL_ControllerButtonEvent](https://wiki.libsdl.org/SDL_ControllerButtonEvent)
* [SDL_ControllerDeviceEvent](https://wiki.libsdl.org/SDL_ControllerDeviceEvent)
* [SDL_AudioDeviceEvent](https://wiki.libsdl.org/SDL_AudioDeviceEvent)
* [SDL_QuitEvent](https://wiki.libsdl.org/SDL_QuitEvent)
* [SDL_UserEvent](https://wiki.libsdl.org/SDL_UserEvent)
* [SDL_SysWMEvent](https://wiki.libsdl.org/SDL_SysWMEvent)
* [SDL_TouchFingerEvent](https://wiki.libsdl.org/SDL_TouchFingerEvent)
* [SDL_MultiGestureEvent](https://wiki.libsdl.org/SDL_MultiGestureEvent)
* [SDL_DollarGestureEvent](https://wiki.libsdl.org/SDL_DollarGestureEvent)
* [SDL_DropEvent](https://wiki.libsdl.org/SDL_DropEvent)
]]
local Nene.EventsCallbacks = @record{
  -- keyboard-related events
  key_cb     : function(key     : SDL_KeyboardEvent),         -- key keyboard event data
  edit_cb    : function(edit    : SDL_TextEditingEvent),      -- edit text editing event data
  text_cb    : function(text    : SDL_TextInputEvent),        -- text text input event data

  -- mouse events
  motion_cb  : function(motion  : SDL_MouseMotionEvent),      -- motion mouse motion event data
  button_cb  : function(button  : SDL_MouseButtonEvent),      -- button mouse button event data
  wheel_cb   : function(wheel   : SDL_MouseWheelEvent),       -- wheel mouse wheel event data

  -- joystick events
  jaxis_cb   : function(jaxis   : SDL_JoyAxisEvent),          -- jaxis joystick axis event data
  jball_cb   : function(jball   : SDL_JoyBallEvent),          -- jball joystick ball event data
  jhat_cb    : function(jhat    : SDL_JoyHatEvent),           -- jhat joystick hat event data
  jbutton_cb : function(jbutton : SDL_JoyButtonEvent),        -- jbutton joystick button event data
  jdevice_cb : function(jdevice : SDL_JoyDeviceEvent),        -- jdevice joystick device event data

  -- game controller events
  caxis_cb   : function(caxis   : SDL_ControllerAxisEvent),   -- caxis game controller axis event data
  cbutton_cb : function(cbutton : SDL_ControllerButtonEvent), -- cbutton game controller button event data
  cdevice_cb : function(cdevice : SDL_ControllerDeviceEvent), -- cdevice game controller device event data

  -- touch/finger events
  tfinger_cb : function(tfinger : SDL_TouchFingerEvent),      -- tfinger touch finger event data
  mgesture_cb: function(mgesture: SDL_MultiGestureEvent),     -- mgesture multi finger gesture data
  dgesture_cb: function(dgesture: SDL_DollarGestureEvent),    -- dgesture multi finger gesture data

  -- etc
  adevice_cb : function(adevice : SDL_AudioDeviceEvent),      -- adevice audio device event data (>= SDL 2.0.4)
  quit_cb    : function(quit    : SDL_QuitEvent),             -- quit quit request event data
  user_cb    : function(user    : SDL_UserEvent),             -- user custom event data
  syswm_cb   : function(syswm   : SDL_SysWMEvent),            -- syswm system dependent window event data
  drop_cb    : function(drop    : SDL_DropEvent),             -- drag and drop event data
  window_cb  : function(window  : SDL_WindowEvent),           -- window window event data
}

--[[
You should call this method at the start of each game loop tick, it:
1. Polls all SDL events;
2. Updates the `self.quit` boolean value, it becomes `true` when the appplication will quit (see SDL_QuitEvent);
3. Calls the respective callbacks.

Related Nene documentation:
* [Nene.EventsCallbacks](#neneeventscallbacks)

Related SDL documentation:
* [SDL_PollEvent](https://wiki.libsdl.org/SDL_PollEvent)
]]
function Nene:poll_events(evt_callbacks: Nene.EventsCallbacks)
  check(Nene.initialized, 'Nene is not initialized')

  -- utils
  local function find_gamepad_idx_from_joystick_id(self: *Nene, joystick_id: cint): (boolean, usize)
    for i = 0_us, < #self.gamepads_state do
      if self.gamepads_state[i].joystick_id == joystick_id then
        return true, i
      end
    end
    return false, 0
  end

  local function find_next_available_gamepad(self: *Nene): (boolean, usize)
    for i = 0_us, < #self.gamepads_state do
      if not self.gamepads_state[i].active then
        return true, i
      end
    end
    return false, 0
  end

  -- internal state updates
  local function update_keyboard_state(self: *Nene, key: *SDL_KeyboardEvent)
    check(self, 'self argument is nilptr')
    check(key, 'key argument is nilptr')

    self.keyboard_state[key.keysym.scancode] = key.state == SDL_PRESSED
  end

  local function update_mouse_buttons_state(self: *Nene, button: *SDL_MouseButtonEvent)
    check(self, 'self argument is nilptr')
    check(button, 'button argument is nilptr')

    self.mouse_pos = { button.x, button.y }
    self.mouse_buttons[button.button - 1] = button.state == SDL_PRESSED
  end

  local function update_mouse_motion_state(self: *Nene, motion: *SDL_MouseMotionEvent)
    check(self, 'self argument is nilptr')
    check(motion, 'motion argument is nilptr')

    self.mouse_pos = { motion.x, motion.y  }
    self.mouse_relative_motion = { motion.xrel, motion.yrel }
  end

  local function update_controller_button_state(self: *Nene, cbutton: *SDL_ControllerButtonEvent)
    check(self, 'self argument is nilptr')
    check(cbutton, 'cbutton argument is nilptr')

    local ok, gamepad_idx = find_gamepad_idx_from_joystick_id(self, cbutton.which)

    if not ok then
      return
    end

    local gamepad_state = &self.gamepads_state[gamepad_idx]
    check(gamepad_state.active, "Trying to update the buttons state of an inactive gamepad, this is an unexpected nene bug, please report it.")

    switch cbutton.state do
    case SDL_PRESSED then
      gamepad_state.buttons[cbutton.button] = true

    case SDL_RELEASED then
      gamepad_state.buttons[cbutton.button] = false
    end
  end

  local function update_controller_device_state(self: *Nene, cdevice: *SDL_ControllerDeviceEvent)
    check(self, 'self argument is nilptr')
    check(cdevice, 'cdevice argument is nilptr')

    switch cdevice.type do
    case SDL_CONTROLLERDEVICEADDED then

      if cdevice.which >= #self.gamepads_state then
        return
      end

      local ok, gamepad_idx = find_next_available_gamepad(self)

      if not ok then
        return
      end

      local gamepad_state = &self.gamepads_state[gamepad_idx]
      check(not gamepad_state.active, "Gamepad added on an active gamepad, this is an unexpected nene bug, please report it.")

      local joystick_id = SDL_JoystickGetDeviceInstanceID(cdevice.which)
      if joystick_id < 0 then
        return
      end

      local game_controller = SDL_GameControllerOpen(cdevice.which)
      if not game_controller then
        warn_msg!('Nene.poll_events', 'could open game controller once the device got added')
        return
      end

      $gamepad_state = {
        active = true,
        =game_controller,
        =joystick_id,
      }
    case SDL_CONTROLLERDEVICEREMOVED then

      if cdevice.which >= #self.gamepads_state then
        return
      end

      local ok, gamepad_idx = find_gamepad_idx_from_joystick_id(self, cdevice.which)

      if not ok then
        return
      end

      local gamepad_state = &self.gamepads_state[gamepad_idx]
      check(gamepad_state.joystick_id == cdevice.which, "Gamepad joystick instances id doesn't match, this is an unexpected nene bug, please report it.")
      check(gamepad_state.active, "Gamepad removed on a inactive gamepad, this is an unexpected nene bug, please report it.")

      SDL_GameControllerClose(gamepad_state.game_controller)

      $gamepad_state = {
        active = false,
      }
    end
  end

  -- reset some state manually
  self.mouse_relative_motion = {}
  self.prev_keyboard_state = self.keyboard_state
  self.prev_mouse_buttons = self.mouse_buttons
  for i = 0, < #self.gamepads_state do
    self.gamepads_state[i].prev_buttons = self.gamepads_state[i].buttons
  end

  local evt: SDL_Event;

  -- poll all the events and update the respective internal states
  while SDL_PollEvent(evt) == 1 do
    if evt.type == SDL_QUIT	then
      self.quit = true
    end

    switch evt.type do
      case SDL_QUIT then
        if evt_callbacks.quit_cb then evt_callbacks.quit_cb(evt.quit) end

      case SDL_CONTROLLERAXISMOTION then
        if evt_callbacks.caxis_cb then evt_callbacks.caxis_cb(evt.caxis) end

      case SDL_CONTROLLERBUTTONDOWN, SDL_CONTROLLERBUTTONUP then
        update_controller_button_state(self, evt.cbutton)
        if evt_callbacks.cbutton_cb then evt_callbacks.cbutton_cb(evt.cbutton) end

      case SDL_CONTROLLERDEVICEADDED, SDL_CONTROLLERDEVICEREMOVED, SDL_CONTROLLERDEVICEREMAPPED then
        update_controller_device_state(self, evt.cdevice)
        if evt_callbacks.cdevice_cb then evt_callbacks.cdevice_cb(evt.cdevice) end

      case SDL_DOLLARGESTURE, SDL_DOLLARRECORD then
        if evt_callbacks.dgesture_cb then evt_callbacks.dgesture_cb(evt.dgesture) end

      case SDL_DROPFILE, SDL_DROPTEXT, SDL_DROPBEGIN, SDL_DROPCOMPLETE then
        if evt_callbacks.drop_cb then evt_callbacks.drop_cb(evt.drop) end

      case SDL_FINGERMOTION, SDL_FINGERDOWN, SDL_FINGERUP then
        if evt_callbacks.tfinger_cb then evt_callbacks.tfinger_cb(evt.tfinger) end

      case SDL_KEYDOWN, SDL_KEYUP then
        update_keyboard_state(self, evt.key)
        if evt_callbacks.key_cb then evt_callbacks.key_cb(evt.key) end

      case SDL_JOYAXISMOTION then
        if evt_callbacks.jaxis_cb then evt_callbacks.jaxis_cb(evt.jaxis) end

      case SDL_JOYBALLMOTION then
        if evt_callbacks.jball_cb then evt_callbacks.jball_cb(evt.jball) end

      case SDL_JOYHATMOTION then
        if evt_callbacks.jhat_cb then evt_callbacks.jhat_cb(evt.jhat) end

      case SDL_JOYBUTTONDOWN, SDL_JOYBUTTONUP then
        if evt_callbacks.jbutton_cb then evt_callbacks.jbutton_cb(evt.jbutton) end

      case SDL_JOYDEVICEADDED, SDL_JOYDEVICEREMOVED then
        if evt_callbacks.jdevice_cb then evt_callbacks.jdevice_cb(evt.jdevice) end

      case SDL_MOUSEMOTION then
        update_mouse_motion_state(self, evt.motion)
        if evt_callbacks.motion_cb then evt_callbacks.motion_cb(evt.motion) end

      case SDL_MOUSEBUTTONDOWN, SDL_MOUSEBUTTONUP then
        update_mouse_buttons_state(self, evt.button)
        if evt_callbacks.button_cb then evt_callbacks.button_cb(evt.button) end

      case SDL_MOUSEWHEEL then
        if evt_callbacks.wheel_cb then evt_callbacks.wheel_cb(evt.wheel) end

      case SDL_MULTIGESTURE then
        if evt_callbacks.mgesture_cb then evt_callbacks.mgesture_cb(evt.mgesture) end

      case SDL_SYSWMEVENT then
        if evt_callbacks.syswm_cb then evt_callbacks.syswm_cb(evt.syswm) end

      case SDL_TEXTEDITING then
        if evt_callbacks.edit_cb then evt_callbacks.edit_cb(evt.edit) end

      case SDL_TEXTINPUT then
        if evt_callbacks.text_cb then evt_callbacks.text_cb(evt.text) end

      case SDL_USEREVENT then
        if evt_callbacks.user_cb then evt_callbacks.user_cb(evt.user) end

      case SDL_WINDOWEVENT then
        if evt_callbacks.window_cb then evt_callbacks.window_cb(evt.window) end

      case SDL_AUDIODEVICEADDED, SDL_AUDIODEVICEREMOVED then
        if evt_callbacks.adevice_cb then evt_callbacks.adevice_cb(evt.adevice) end
    end
  end

  -- update delta_time and current_time
  local cur_time = SDL_GetTicks() -- Note: change to SDL_GetTicks64 in the future (not soon)
  self.delta_time = (cur_time - self.current_time) / 1000
  self.current_time = cur_time
end

--[[
Get the size of the current window.

Related SDL documentation:
* [SDL_GetWindowSize](https://wiki.libsdl.org/SDL_GetWindowSize)
]]
function Nene:get_window_size(): (cint, cint)
  check(Nene.initialized, 'Nene is not initialized')

  local w: cint, h: cint
  SDL_GetWindowSize(self.window, &w, &h)

  return w, h
end

--[[
Returns if the passed `scancode` it's pressed down, that is, if it's currently pressed now, but it wasn't on
the previous frame.

> Scancode it's a keyboard-layout independent "key", for more details, read SDL's documentation about Scancodes.

Related Nene documentation:
* [Scancode](scancode.md)
* [Nene.get_scancode](init.md#neneget_scancode)
* [Nene.get_scancode_up](init.md#neneget_scancode_up)

Related SDL documentation:
* [SDL_Scancode](https://wiki.libsdl.org/SDL_Scancode)
* [SDL_GetKeyboardState](https://wiki.libsdl.org/SDL_GetKeyboardState)
]]
function Nene:get_scancode_down(scancode: Nene.Scancode): boolean
  check(Nene.initialized, 'Nene is not initialized')
  return self.keyboard_state[scancode] and not self.prev_keyboard_state[scancode]
end

--[[
Returns if the passed `scancode` was unpressed, that is, if it isn't currently pressed now, but it was on
the previous frame.

Related Nene documentation:
* [Scancode](scancode.md)
* [Nene.get_scancode](init.md#neneget_scancode)
* [Nene.get_scancode_down](init.md#neneget_scancode_down)

Related SDL documentation:
* [SDL_Scancode](https://wiki.libsdl.org/SDL_Scancode)
* [SDL_GetKeyboardState](https://wiki.libsdl.org/SDL_GetKeyboardState)
]]
function Nene:get_scancode_up(scancode: Nene.Scancode): boolean
  check(Nene.initialized, 'Nene is not initialized')
  return not self.keyboard_state[scancode] and self.prev_keyboard_state[scancode]
end

--[[
Returns the current state of `scancode`, that is, if it's currently pressed now.

> Scancode it's a keyboard-layout independent "key", for more details, read SDL's documentation about Scancodes.

Related Nene documentation:
* [Scancode](scancode.md)
* [Nene.get_scancode_down](init.md#neneget_scancode_down)
* [Nene.get_scancode_up](init.md#neneget_scancode_up)

Related SDL documentation:
* [SDL_Scancode](https://wiki.libsdl.org/SDL_Scancode)
* [SDL_GetKeyboardState](https://wiki.libsdl.org/SDL_GetKeyboardState)
]]
function Nene:get_scancode(scancode: Nene.Scancode, is_down: facultative(boolean)): boolean
  check(Nene.initialized, 'Nene is not initialized')

  ## if is_down.type.is_niltype then
    return self.keyboard_state[scancode]
  ## else
    ## print('DEPRECATED: `is_down` parameter is now deprecated, please use `get_scancode_down` and `get_scancode_up` instead')
    if is_down then
      return self:get_scancode_down(scancode)
    else
      return self:get_scancode_up(scancode)
    end
  ## end
end

--[[
Returns if a certain gamepad button from a gamepad device just got pressed at the current frame.

This function returns `false` when the gamepad isn't opened by nene.

> Note: Nene opens a gamepad automatically once connected.

Related Nene documentation:
* [Gamepad.Button](gamepad.md#gamepadbutton)
* [Nene.get_gamepad_button](init.md#neneget_gamepad_button)
* [Nene.get_gamepad_button_up](init.md#neneget_gamepad_button_up)
* [Nene.get_gamepad_axis](init.md#neneget_gamepad_axis)
]]
function Nene:get_gamepad_button_down(gamepad_index: usize, gamepad_button: gamepad.Button): boolean
  check(Nene.initialized, 'Nene is not initialized')
  check(gamepad_index < #self.gamepads_state, 'invalid gamepad index')
  local gamepad_state = &self.gamepads_state[gamepad_index]
  return gamepad_state.active and gamepad_state.buttons[gamepad_button] and not gamepad_state.prev_buttons[gamepad_button]
end

--[[
Returns if a certain gamepad button from a gamepad device just got released at the current frame.

This function returns `false` when the gamepad isn't opened by nene.

> Note: Nene opens a gamepad automatically once connected.

Related Nene documentation:
* [Gamepad.Button](gamepad.md#gamepadbutton)
* [Nene.get_gamepad_button](init.md#neneget_gamepad_button)
* [Nene.get_gamepad_button_down](init.md#neneget_gamepad_button_down)
* [Nene.get_gamepad_axis](init.md#neneget_gamepad_axis)
]]
function Nene:get_gamepad_button_up(gamepad_index: usize, gamepad_button: gamepad.Button): boolean
  check(Nene.initialized, 'Nene is not initialized')
  check(gamepad_index < #self.gamepads_state, 'invalid gamepad index')
  local gamepad_state = &self.gamepads_state[gamepad_index]
  return gamepad_state.active and not gamepad_state.buttons[gamepad_button] and gamepad_state.prev_buttons[gamepad_button]
end

--[[
Returns if a certain gamepad axis from a gamepad device.

This function returns `false` when the gamepad isn't opened by nene.

> Note: Nene opens a gamepad automatically once connected.

Related Nene documentation:
* [Gamepad.Button](gamepad.md#gamepadbutton)
* [Nene.get_gamepad_button_down](init.md#neneget_gamepad_button_down)
* [Nene.get_gamepad_button_up](init.md#neneget_gamepad_button_up)
* [Nene.get_gamepad_axis](init.md#neneget_gamepad_axis)
]]
function Nene:get_gamepad_button(gamepad_index: usize, gamepad_button: gamepad.Button): boolean
  check(Nene.initialized, 'Nene is not initialized')
  check(gamepad_index < #self.gamepads_state, 'invalid gamepad index')
  local gamepad_state = &self.gamepads_state[gamepad_index]
  return gamepad_state.active and gamepad_state.buttons[gamepad_button]
end

--[[
Returns the value of a certain gamepad button from a gamepad device is currently pressed.

This function returns `0.0` when the gamepad isn't opened by nene.

> Note: Nene opens a gamepad automatically once connected.

Related Nene documentation:
* [Gamepad.Axis](gamepad.md#gamepadaxis)
* [Nene.get_gamepad_button](init.md#neneget_gamepad_button)
* [Nene.get_gamepad_button_down](init.md#neneget_gamepad_button_down)
* [Nene.get_gamepad_button_up](init.md#neneget_gamepad_button_up)
]]
function Nene:get_gamepad_axis(gamepad_index: usize, gamepad_axis: gamepad.Axis): number
  check(Nene.initialized, 'Nene is not initialized')
  check(gamepad_index < #self.gamepads_state, 'invalid gamepad index')
  local gamepad_state = &self.gamepads_state[gamepad_index]
  local axis: int32 = SDL_GameControllerGetAxis(gamepad_state.game_controller, gamepad_axis)
  if math.abs(axis) < 800 then
    axis = 0
  end
  local num_axis: number = axis / #[primtypes.int16.max]#
  return gamepad_state.active and math.clamp(num_axis, -1.0, 1.0) or 0.0
end

--[[
This functions returns if the mouse cursor is visible or not, you can set this status by passing a boolean value.

This function returns two booleans:

1. It's the `ok` status, it's `true` when the function was successful.
2. It's the cursor visibility status, it's `true` when it's visible.

If you want to change the visibility, pass a boolean argument, where `true` make it visible.

Related SDL documentation:
* [SDL_ShowCursor](https://wiki.libsdl.org/SDL_ShowCursor)
]]
function Nene.cursor_visibility(new_visibility: facultative(boolean)): (boolean, boolean)
  ## if new_visibility.type.is_niltype then
  local toggle: cint = SDL_QUERY
  ## else
  local toggle: cint = new_visibility and SDL_ENABLE or SDL_DISABLE
  ## end

  local ok = true
  local raw_result = SDL_ShowCursor(toggle)

  if raw_result < 0 then
    ok = false
    warn_msg!('Nene.cursor_visibility', 'could not get and/or set the cursor visibility')
  end

  return ok, raw_result == SDL_ENABLE
end

--[[
Returns if the `mouse_button`-nth mouse button get's pressed, that is,
if this mouse button was just pressed on the current frame, but it wasn't pressed on the previous frame.

> 0 is the left-click, 1 is middle-click, 2 is right-click, and so on.

Related Nene documentation:
* [Nene.get_mouse_button](init.md#neneget_mouse_button)
* [Nene.get_mouse_button_up](init.md#neneget_mouse_button_up)

Related SDL documentation:
* [SDL_GetMouseState](https://wiki.libsdl.org/SDL_GetMouseState)
]]
function Nene:get_mouse_button_down(mouse_button: isize): boolean
  check(Nene.initialized, 'Nene is not initialized')
  check(mouse_button >= 0 and mouse_button < (#self.mouse_buttons), 'Invalid `mouse_button` value')
  return self.mouse_buttons[mouse_button] and not self.prev_mouse_buttons[mouse_button]
end

--[[
Returns if the `mouse_button`-nth mouse button got unpressed, that is,
if this mouse button isn't pressed on the current frame, but it was pressed on the previous frame.

> 0 is the left-click, 1 is middle-click, 2 is right-click, and so on.

Related Nene documentation:
* [Nene.get_mouse_button](init.md#neneget_mouse_button)
* [Nene.get_mouse_button_down](init.md#neneget_mouse_button_down)

Related SDL documentation:
* [SDL_GetMouseState](https://wiki.libsdl.org/SDL_GetMouseState)
]]
function Nene:get_mouse_button_up(mouse_button: isize): boolean
  check(Nene.initialized, 'Nene is not initialized')
  check(mouse_button >= 0 and mouse_button < (#self.mouse_buttons), 'Invalid `mouse_button` value')
  return not self.mouse_buttons[mouse_button] and self.prev_mouse_buttons[mouse_button]
end

--[[
Returns if the `mouse_button`-nth mouse button is currently pressed.

> 0 is the left-click, 1 is middle-clic, 2 is right-click, and so on.

Related Nene documentation:
* [Nene.get_mouse_button_down](init.md#neneget_mouse_button_down)
* [Nene.get_mouse_button_up](init.md#neneget_mouse_button_up)

Related SDL documentation:
* [SDL_GetMouseState](https://wiki.libsdl.org/SDL_GetMouseState)
]]
function Nene:get_mouse_button(mouse_button: isize, is_down: facultative(boolean)): boolean
  check(Nene.initialized, 'Nene is not initialized')
  check(mouse_button >= 0 and mouse_button < (#self.mouse_buttons), 'Invalid `mouse_button` value')

  ## if is_down.type.is_niltype then
    return self.mouse_buttons[mouse_button]
  ## else
    ## print('DEPRECATED: `is_down` parameter is now deprecated, please use `get_mouse_button_down` and `get_mouse_button_up` instead')

    if is_down then
      return self:get_mouse_button_down(mouse_button)
    else
      return self:get_mouse_button_up(mouse_button)
    end
  ## end
end

--[[
Set the drawing color for rectangles, lines and points rendering.

Returns an `ok` status with `true` value if successful.

Related Nene documentation:
* [Color](color.md#color)

Related SDL documentation:
* [SDL_Color](https://wiki.libsdl.org/SDL_Color)
* [SDL_Renderer](https://wiki.libsdl.org/SDL_Renderer)
* [SDL_SetRenderDrawColor](https://wiki.libsdl.org/SDL_SetRenderDrawColor)
]]
function Nene:set_render_draw_color(color: Color): boolean
  check(Nene.initialized, 'Nene is not initialized')

  if SDL_SetRenderDrawColor(self.renderer, color.r, color.g, color.b, color.a) ~= 0 then
    warn_msg!('Nene.set_render_draw_color', 'could not set rendering color')
    return false
  end

  return true
end

--[[
Set the blend mode for drawing operations.

Returns an `ok` status with `true` value if successful.

Related SDL documentation:
* [SDL_BlendMode](https://wiki.libsdl.org/SDL_BlendMode)
* [SDL_Renderer](https://wiki.libsdl.org/SDL_Renderer)
* [SDL_SetRenderDrawBlendMode](https://wiki.libsdl.org/SDL_SetRenderDrawBlendMode)
]]
function Nene:set_render_draw_blend_mode(blend_mode: SDL_BlendMode): boolean
  check(Nene.initialized, 'Nene is not initialized')

  if SDL_SetRenderDrawBlendMode(self.renderer, blend_mode) ~= 0 then
    warn_msg!('Nene.set_render_draw_blend_mode', 'could not set the rendering blend mode')
    return false
  end

  return true
end

--[[
Set an additional color value multiplied into render copy operations on the passed raw texture.

Returns an `ok` status with `true` value if successful.

Related SDL documentation:
* [SDL_SetTextureColorMod](https://wiki.libsdl.org/SDL_SetTextureColorMod)
]]
function Nene:set_raw_texture_color_mod(raw_texture: *SDL_Texture, color: Color): boolean
  check(Nene.initialized, 'Nene is not initialized')

  if SDL_SetTextureColorMod(raw_texture, color.r, color.g, color.b) ~= 0 then
    warn_msg!('Nene.set_texture_color_mod', 'could not set the texture color modulation')
    return false
  end

  return true
end

--[[
Set clip rectangle for rendering.

Set the passed `rect` as the clipping rectangle, if `nil` is passed, then the clipping is disabled.

Returns an `ok` status with `true` value if successful.

Related Nene documentation:
* [Math.Rect](math/rect.md#rect)

Related SDL documentation:
* [SDL_RenderSetClipRect](https://wiki.libsdl.org/SDL_RenderSetClipRect)
]]
function Nene:set_render_clip(rect: facultative(Rect)): boolean
  check(Nene.initialized, 'Nene is not initialized')

  ## if not rect.type.is_niltype then
  rect.x = rect.x + self.render_offset.x
  rect.y = rect.y + self.render_offset.y

  local sdl_rect: SDL_Rect = rect:to_raw_rect()
  ## else
  local sdl_rect: *SDL_Rect = nilptr
  ## end

  if SDL_RenderSetClipRect(self.renderer, sdl_rect) ~= 0 then
    warn_msg!('Nene.set_render_clip', 'could not set the rendering clip rectangle')
    return false
  end

  return true
end

--[[
It clears the rendering target with the given `color`.

If `color` is not given, then is set to "background color".

Returns an `ok` status with `true` value if successful.

Related Nene documentation:
* [Color](color.md#color)
* [Nene.set_render_draw_color](#neneset_render_draw_color)

Related SDL documentation:
* [SDL_Renderer](https://wiki.libsdl.org/SDL_Renderer)
* [SDL_RenderClear](https://wiki.libsdl.org/SDL_RenderClear)
]]
function Nene:render_clear(color: facultative(Color)): boolean
  check(Nene.initialized, 'Nene is not initialized')

  ## if color.type.is_niltype then
  local color = Color.Palette.bg
  ## end

  self:set_render_draw_color(color)
  if SDL_RenderClear(self.renderer) ~= 0 then
    warn_msg!('Nene.render_clear', 'could not clear the rendering target')
    return false
  end

  return true
end

--[[
Renders a pixel on the `position` position with the given `color`.

If `color` is not given, then is set to white color.

Returns `ok` status with `true` value if successful.

Related Nene documentation:
* [Math.Vec2](math/vec2.md#vec2)
* [Color](color.md#color)

Related SDL documentation:
* [SDL_RenderDrawPoint](https://wiki.libsdl.org/SDL_RenderDrawPoint)
]]
function Nene:render_draw_pixel(position: Vec2, color: facultative(Color)): boolean
  check(Nene.initialized, 'Nene is not initialized')

  ## if color.type.is_niltype then
  local color = Color.Palette.white
  ## end

  self:set_render_draw_color(color)

  local pos_x: cint, pos_y: cint = math.ifloor(position.x), math.ifloor(position.y)

  if SDL_RenderDrawPoint(self.renderer, pos_x, pos_y) ~= 0 then
    warn_msg!('Nene.render_draw_pixel', 'coult not draw a pixel')
    return false
  end

  return true
end


--[[
Renders a line from `origin` to `destination` with the given `color`.

If `color` is not given, then is set to white color.

Returns an `ok` status with `true` value if successful.

Related Nene documentation:
* [Math.Vec2](math/vec2.md#vec2)
* [Color](color.md#color)

Related SDL documentation:
* [SDL_RenderDrawLine](https://wiki.libsdl.org/SDL_RenderDrawLine)
]]
function Nene:render_draw_line(origin: Vec2, destination: Vec2, color: facultative(Color)): boolean
  ## if color.type.is_niltype then
  local color = Color.Palette.white
  ## end

  check(Nene.initialized, 'Nene is not initialized')

  self:set_render_draw_color(color)

  local origin_px: cint, origin_py: cint, dest_px: cint, dest_py: cint = math.ifloor(origin.x + self.render_offset.x),
                                                                         math.ifloor(origin.y + self.render_offset.y),
                                                                         math.ifloor(destination.x + self.render_offset.x),
                                                                         math.ifloor(destination.y + self.render_offset.y)

  if SDL_RenderDrawLine(self.renderer, origin_px, origin_py, dest_px, dest_py) ~= 0 then
    warn_msg!('Nene.render_draw_line', 'could not draw a line')
    return false
  end

  return true
end

--[[
Renders the given `rectangle` with the given `color`; it will be filled if `use_lines` is `false`.

If `color` is not given, then is set to white color.

Returns an `ok` status with `true` value if successful.

Related Nene documentation:
* [Math.Rect](math/rect.md#rect)

Related SDL documentation:
* [SDL_RenderDrawRect](https://wiki.libsdl.org/SDL_RenderDrawRect)
* [SDL_RenderFillRect](https://wiki.libsdl.org/SDL_RenderFillRect)
]]
function Nene:render_draw_rect(rectangle: overload(Rect, Rectf), use_lines: boolean, color: facultative(Color)): boolean
  ## if color.type.is_niltype then
  local color = Color.Palette.white
  ## end

  check(Nene.initialized, 'Nene is not initialized')

  local rectangle = rectangle:with_position(rectangle:get_position() + self.render_offset)
  local sdl_rect: SDL_Rect = rectangle:to_raw_rect()

  self:set_render_draw_color(color)

  if use_lines then
    if SDL_RenderDrawRect(self.renderer, sdl_rect) ~= 0 then
      warn_msg!('Nene.render_draw_rect', 'could not draw a rectangle')
      return false
    end
  else
    if SDL_RenderFillRect(self.renderer, sdl_rect) ~= 0 then
      warn_msg!('Nene.render_fill_rect', 'could not draw a filled rectangle')
      return false
    end
  end

  return true
end

--[[
Wrapper of `SDL_RenderCopy`.
Copies `texture` on the rendering target.

By default the whole texture is copied unless the `source` rectangle is given,
in this case only the "source" part of the texture will be copied.

By default the texture will be copied on the whole rendering target unless the `destination` rectangle is given,
in this case it will be copied at this "destination" part of the rendering target.

Returns an `ok` status with `true` value if successful.

There also some extra parameters with more advanced options:
- `angle`: Rotates the destination rectangle in degrees in clockwise direction.
- `rotation_center`: Defines the point of rotation of the previous parameter, the values are expected to be between `0` and `1`.
- `flip_horizontal`: Flips the texture horizontally on painting.
- `flip_vertically`: Flips the texture vertically on painting.

Related Nene documentation:
* [Math.Rect](math/rect.md#rect)

Related SDL documentation:
* [SDL_Texture](https://wiki.libsdl.org/SDL_Texture)
* [SDL_RenderCopy](https://wiki.libsdl.org/SDL_RenderCopy)
* [SDL_RenderCopyEx](https://wiki.libsdl.org/SDL_RenderCopyEx)
]]
function Nene:render_copy(
  texture: *SDL_Texture,
  source: facultative(Rect),
  destination: facultative(Rect),
  angle: facultative(number),
  rotation_center: facultative(Vec2),
  flip_horizontal: facultative(boolean),
  flip_vertical: facultative(boolean)
): boolean
  check(Nene.initialized, 'Nene is not initialized')

  local src: *SDL_Rect, dest: *SDL_Rect;

  ## if not source.type.is_niltype then
  local src_rect: SDL_Rect = source:to_raw_rect()
  src = &src_rect
  ## end

  ## if not destination.type.is_niltype then
  local destination = destination:with_position(destination:get_position() + self.render_offset)
  local dest_rect: SDL_Rect = destination:to_raw_rect()
  dest = &dest_rect
  ## end

  ## local use_ex = not (angle.type.is_niltype and rotation_center.type.is_niltype and flip_horizontal.type.is_niltype and flip_vertical.type.is_niltype)

  ## if not use_ex then
    if SDL_RenderCopy(self.renderer, texture, src, dest) ~= 0 then
      warn_msg!('Nene.render_copy', 'could not copy the texture portion to the rendering target')
      return false
    end
  ## else
    ## if angle.type.is_niltype then
    local angle = 0
    ## end

    local rot_center_vl: SDL_Point = {0, 0}
    local rot_center_ptr: *SDL_Point = nilptr
    local flip_vl = SDL_FLIP_NONE

    ## if not rotation_center.type.is_niltype then
      rot_center_vl.x, rot_center_vl.y = math.ifloor(destination.w * rotation_center.x), math.ifloor(destination.h * rotation_center.y)
      rot_center_ptr = &rot_center_vl
    ## end

    ## if not flip_horizontal.type.is_niltype then
      flip_vl = flip_horizontal and SDL_FLIP_HORIZONTAL or SDL_FLIP_NONE
    ## end

    ## if not flip_vertical.type.is_niltype then
      flip_vl = flip_vl | (flip_vertical and SDL_FLIP_VERTICAL or SDL_FLIP_NONE)
    ## end

    if SDL_RenderCopyEx(self.renderer, texture, src, dest, angle, rot_center_ptr, flip_vl) ~= 0 then
      warn_msg!('Nene.render_copy', 'could not copy the texture portion to the rendering target')
      return false
    end
  ## end

  return true
end

--[[
Set a `texture_target` as rendering target.

If `nilptr` is given for `texture_target`, then the target will be the window itself.

Returns an `ok` status with `true` value if successful.

Related SDL documentation:
* [SDL_SetRenderTarget](https://wiki.libsdl.org/SDL_SetRenderTarget)
]]
function Nene:set_render_target(texture_target: facultative(*SDL_Texture)): boolean
  check(Nene.initialized, 'Nene is not initialized')

  ## if texture_target.type.is_niltype then
  ## print('DEPRECATED: passing `nil` on `texture_target` parameter is now deprecated, please use `nilptr` instead')
  local texture_target: *SDL_Texture = nilptr
  ## end

  if SDL_SetRenderTarget(self.renderer, texture_target) ~= 0 then
    warn_msg!('Nene.set_render_target', 'could not set the `texture_target` as the rendering target')
    return false
  end

  return true
end

--[[
Wrapper of `SDL_CreateTexture`.

Creates a Texture for the rendering context.

Returns an `ok` status with `true` value if successful and the created Texture as `SDL_Texture`.

> Note: You can pass a `Texture.Acess` argument on the `access` parameter.

Related Nene documentation:
* [Texture.Access](texture.md#textureaccess)

Related SDL documentation:
* [SDL_Texture](https://wiki.libsdl.org/SDL_Texture)
* [SDL_CreateTexture](https://wiki.libsdl.org/SDL_CreateTexture)
* [SDL_TextureAccess](https://wiki.libsdl.org/SDL_TextureAccess)
]]
function Nene:create_raw_texture(format: uint32, access: SDL_TextureAccess, width: cint, height: cint): (boolean, *SDL_Texture)
  check(Nene.initialized, 'Nene is not initialized')

  local ok = true
  local texture = SDL_CreateTexture(self.renderer, format, access, width, height)

  if not texture then
    ok = false
    warn_msg!('Nene.create_raw_texture', 'could not create texture for the rendering context')
  end

  return ok, texture
end

--[[
Wrapper of `SDL_CreateTextureFromSurface`.

Creates a Texture from the given surface.

Returns an `ok` status with `true` value if successful and the created Texture as `SDL_Texture`.

Related SDL documentation:
* [SDL_Texture](https://wiki.libsdl.org/SDL_Texture)
* [SDL_Surface](https://wiki.libsdl.org/SDL_Surface)
* [SDL_CreateTextureFromSurface](https://wiki.libsdl.org/SDL_CreateTextureFromSurface)
]]
function Nene:create_raw_texture_from_surface(surface_ref: *SDL_Surface): (boolean, *SDL_Texture)
  check(Nene.initialized, 'Nene is not initialized')
  check(surface_ref ~= nilptr, "cannot create a texture from a nilptr")

  local ok = true
  local texture = SDL_CreateTextureFromSurface(self.renderer, surface_ref)

  if not texture then
    ok = false
    warn_msg!('Nene.create_raw_texture_from_surface', 'could not create texture from the given surface')
  end

  return ok, texture
end

--[[
presents the SDL's composed backbuffer (any rendering operation is done on the SDL's backbuffer,
this function presents it).

This also does some modification on the state, preparing it for the next frame.

Related SDL documentation:
* [SDL_RenderPresent](https://wiki.libsdl.org/SDL_RenderPresent)
]]
function Nene:render_present()
  check(Nene.initialized, 'Nene is not initialized')
  SDL_RenderPresent(self.renderer)
end

--[[
Try to initialize nene and returns an `ok` status and a new initilized core state.

returns:
  * a boolean that with `true` value on success or `false` on failure.
  * a new state, only initialized on success.

notes:
  * You **always** should first check if the initialization
  succeeded before trying to use the state.

Code example:
```lua
-- initialize nene
local ok, nene = Nene.init('My game title', 1280, 720)

-- test if nene got successfully initialized, here `assert`
-- is used instead of `check`, this way, this test is also done
-- in release mode.
assert(ok, 'error: nene initialization failed')

-- defers nene termination, to release resources used by nene;
-- you can also declare nene as a to-be-closed variable using `nene <close> = ...`
-- syntax, this way, nene will be terminated at the scope end and the defer block
-- will be unnecessary.
defer
  nene:terminate()
end
```

Related SDL documentation:
* [SDL_Init](https://wiki.libsdl.org/SDL_Init)
* [SDL_CreateWindow](https://wiki.libsdl.org/SDL_CreateWindow)
* [SDL_CreateRenderer](https://wiki.libsdl.org/SDL_CreateRenderer)
* [SDL_SetRenderDrawBlendMode](https://wiki.libsdl.org/SDL_SetRenderDrawBlendMode)

Related SDL_mixer documentation:
* [Mix_Init](https://www.libsdl.org/projects/SDL_mixer/docs/SDL_mixer_9.html)
* [Mix_OpenAudio](https://www.libsdl.org/projects/SDL_mixer/docs/SDL_mixer_11.html)

Related SDL_image documentation:
* [IMG_Init](https://www.libsdl.org/projects/SDL_image/docs/SDL_image_8.html)

Related SDL_ttf documentation:
* [TTF_Init](https://github.com/libsdl-org/SDL_ttf/blob/9a2cb0e452a52045419c3554e4c6696a3cd0a714/SDL_ttf.h#L110-L111)
]]
function Nene.init(
  title: string,
  window_size_x: integer, window_size_y: integer,
  pos_x: facultative(integer), pos_y: facultative(integer),
  flags: facultative(uint32)
): (boolean, *Nene)
  check(not Nene.initialized, "Cannot re-initialize Nene")
  check(window_size_x > 0 and window_size_y > 0, 'cannot create a window with `0` as a size parameter')

  -- shadowing arguments with default settings
  ## if pos_x.type.is_niltype then
  local pos_x = SDL_WINDOWPOS_UNDEFINED
  ## end
  ## if pos_y.type.is_niltype then
  local pos_y = SDL_WINDOWPOS_UNDEFINED
  ## end
  ## if flags.type.is_niltype then
  local flags = SDL_WINDOW_SHOWN
  ## end

  -- init libraries
  if SDL_Init(SDL_INIT_VIDEO | SDL_INIT_AUDIO | SDL_INIT_GAMECONTROLLER) ~= 0 then
    warn_msg!('Nene.init', 'could not initialize SDL')
    return false, nilptr
  end

  local img_flags = IMG_INIT_PNG

  if IMG_Init(img_flags) & img_flags ~= img_flags then
    warn_msg!('Nene.init', 'could not initialize SDL_image', 'IMG_GetError')
    return false, nilptr
  end

  if Mix_OpenAudio(MIX_DEFAULT_FREQUENCY, MIX_DEFAULT_FORMAT, 2, 2048) ~= 0 then
    warn_msg!('Nene.init', 'could not initialize mixer API', 'Mix_GetError')
    return false, nilptr
  end

  local mix_flags = MIX_INIT_OGG
  if Mix_Init(mix_flags) & mix_flags ~= mix_flags then
    warn_msg!('Nene.init', 'could not initialize mixer', 'Mix_GetError')
    return false, nilptr
  end

  if TTF_Init() ~= 0 then
    warn_msg!('Nene.init', 'could not initialize mixer', 'TTF_GetError')
    return false, nilptr
  end

  local window = SDL_CreateWindow(title, pos_x, pos_y, window_size_x, window_size_y, flags)
  if not window then
    warn_msg!('Nene.init', 'could not create the window')
    return false, nilptr
  end

  local renderer = SDL_CreateRenderer(window, -1, SDL_RENDERER_ACCELERATED | SDL_RENDERER_PRESENTVSYNC)
  if not renderer then
    warn_msg!('Nene.init', 'could not create the 2D renderer')
    return false, nilptr
  end

  -- libraries initialized, window and renderer initialized and created, thus Nene is considered initialized
  Nene.initialized = true

  -- almost everything setup!
  instance = {
    delta_time = (1 / 60), -- fake delta time targeting 60 fps, this avoids a wrong delta time of 0s.
    =window,
    =renderer,
  }

  instance:set_render_draw_color(Color.Palette.white)
  instance:set_render_draw_blend_mode(SDL_BLENDMODE_BLEND)

  return true, &instance
end

--[[
Closes all game controllers, destroys internal required resources and quits all SDL subsystems.

Note that you still should destroy your own resources like textures, audio, etc.

Related SDL documentation:
* [SDL_GameControllerClose](https://wiki.libsdl.org/SDL_GameControllerClose)
* [SDL_DestroyRenderer](https://wiki.libsdl.org/SDL_DestroyRenderer)
* [SDL_DestroyWindow](https://wiki.libsdl.org/SDL_DestroyWindow)
* [SDL_Quit](https://wiki.libsdl.org/SDL_Quit)

Related SDL_image documentation:
* [IMG_Quit](https://www.libsdl.org/projects/SDL_image/docs/SDL_image_9.html)

Related SDL_ttf documentation:
* [TTF_Quit](https://github.com/libsdl-org/SDL_ttf/blob/9a2cb0e452a52045419c3554e4c6696a3cd0a714/SDL_ttf.h)

Related SDL_mixer documentation:
* [Mix_CloseAudio](https://www.libsdl.org/projects/SDL_mixer/docs/SDL_mixer_12.html)
* [Mix_Quit](https://www.libsdl.org/projects/SDL_mixer/docs/SDL_mixer_10.html)
]]
function Nene:terminate()
  check(Nene.initialized, 'Nene is not initialized')

  Nene.initialized = false

  for i = 0, < #self.gamepads_state do
    if self.gamepads_state[i].active then
      SDL_GameControllerClose(self.gamepads_state[i].game_controller)
    end
  end

  SDL_DestroyRenderer(self.renderer)
  self.renderer = nilptr

  SDL_DestroyWindow(self.window)
  self.window = nilptr

  TTF_Quit()

  Mix_Quit()
  Mix_CloseAudio()

  IMG_Quit()

  SDL_Quit()
end

-- Effectively the same as `terminate`, called when a to-be-closed variable goes out of scope.
function Nene:__close()
  self:terminate()
end

return Nene
