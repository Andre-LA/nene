-- see pong and spritesheet for more details about nene itself

local Nene = require 'nene'
local Color = require 'nene.color'
local Rect = require 'nene.math.rect'

local function rects()
  local ok, nene = Nene.init('nene rects', 256, 256)
  assert(ok, 'error: nene initialization failed')
  defer nene:terminate() end

  -- create two rects
  local rect_a: Rect, rect_b: Rect = {0, 0, 42, 32}, {64, 64, 128, 64}

  repeat
    nene:poll_events()

    -- copy mouse position to rect_a position
    rect_a = rect_a:with_position(nene.mouse_pos)

    -- create a third rect, which is a resolved collision between the
    -- two above, note that is a very simple collision algorhythm
    local is_intersecting, col_rect = rect_a:simple_collision(rect_b)

    nene:render_clear(Color.Palette.bg)

    -- draw both rects with white lines
    nene:render_draw_rect(rect_a, true, Color.Palette.white)
    nene:render_draw_rect(rect_b, true) -- when a color is not passed, then `Color.Palette.white` will be used

    -- draw cyan filled rect with the collision resolved
    if is_intersecting then
      nene:render_draw_rect(col_rect, false, Color.Palette.cyan)
    end

    -- draw intersection with yellow filled rect
    local intersection, is_intersecting = rect_a:get_intersection(rect_b)
    if is_intersecting then
      nene:render_draw_rect(intersection, false, Color.Palette.yellow)
    end

    nene:render_present()
  until nene.quit
end

rects()
