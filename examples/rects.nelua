-- see pong and spritesheet for more details about nene itself

require 'nene.core'
require 'nene.colors'
require 'nene.math'

local function rects()
  local ok, nene = Nene.init('Rects examples', 256, 256)
  assert(ok, 'error: nene initialization failed')
  defer nene:terminate() end

  -- create two rects
  local rect_a: Math.Rect, rect_b: Math.Rect = {0, 0, 32, 32}, {64, 64, 64, 64}

  repeat
    nene:poll_events()

    -- copy mouse position to rect_a position
    local _, mouse_x, mouse_y = SDLWrapper.get_mouse_state()
    rect_a.x, rect_a.y = mouse_x, mouse_y

    -- create a third rect, which is a resolved collision between the
    -- two above, note that is a very simple collision algorhythm
    local is_intersecting, col_rect = rect_a:simple_collision(rect_b)

    nene:render_clear(Color.Palette.bg)

    -- draw both rects with white lines
    nene:render_draw_rect(rect_a, true, Color.Palette.white)
    nene:render_draw_rect(rect_b, true, Color.Palette.white)

    if is_intersecting then
      nene:render_draw_rect(col_rect, false, Color.Palette.cyan)
    end

    -- draw intersection with red filled rect
    local intersection, is_intersecting = rect_a:get_intersection(rect_b)
    if is_intersecting then
      nene:render_draw_rect(intersection, false, Color.Palette.yellow)
    end

    nene:render_present()
  until nene.quit
end

rects()
