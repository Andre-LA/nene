-- basic pong example!

require 'math'
require 'string'

-- you can require each nene module individually,
-- here, we are requiring all modules at once for the sake of simplicity
require 'nene'

local Rect, Vec2, TextTexture = Nene.Math.Rect, Nene.Math.Vec2, Nene.TextTexture

-- general game settings
local SETTINGS: record{
  winsize: Vec2,
  racket: record{
    size: Vec2,
    velocity: integer,
  },
  ball: record{
    size: integer,
    velocity: integer,
  }
} <const> = {
  winsize = { 640, 360 },
  racket = {
    size = { 20, 100 },
    velocity = 4,
  },
  ball = {
    size = 10,
    velocity = 5,
  }
}

-- pong code:

-- racket record
local Racket = @record{
  pos_y: integer,
  points: integer,
}

-- return the rect of the racket
function Racket:get_rect(is_player_one: boolean): Rect
  return (@Rect){
    x = math.ifloor(is_player_one and 20 or SETTINGS.winsize.x - SETTINGS.racket.size.x - 20),
    y = self.pos_y,
    w = SETTINGS.racket.size.x, h = SETTINGS.racket.size.y
  }
end

-- racket's gameplay code
function Racket:update(nene_core: Nene.Core, is_player_one: boolean <comptime>)
  -- input
  local is_up, is_down = false, false

  ## if is_player_one.value then
    is_up, is_down = nene_core:get_scancode(SDL_SCANCODE_W), nene_core:get_scancode(SDL_SCANCODE_S)
  ## else
    is_up, is_down = nene_core:get_scancode(SDL_SCANCODE_I), nene_core:get_scancode(SDL_SCANCODE_K)
  ## end

  -- movement
  local ylimit <const> = SETTINGS.winsize.y - SETTINGS.racket.size.y

  if is_up then
    self.pos_y = math.clamp(self.pos_y - SETTINGS.racket.velocity, 0, ylimit)
  end

  if is_down then
    self.pos_y = math.clamp(self.pos_y + SETTINGS.racket.velocity, 0, ylimit)
  end
end

-- draw a racket
function Racket:draw(nene_core: Nene.Core, is_player_one: boolean)
  nene_core:render_draw_rect(self:get_rect(is_player_one), false, Nene.Palette.yellow)
end

-- ball record
local Ball = @record{
  pos: Vec2,
  direction: Vec2,
}

function Ball.new()
  return (@Ball){
    pos = { SETTINGS.winsize.x // 2, SETTINGS.winsize.y // 2 },
    direction = { 1, 1 },
  }
end

-- return the ball's rect
function Ball:get_rect(): Rect
  return (@Rect){
    x = self.pos.x, y = self.pos.y,
    w = SETTINGS.ball.size, h = SETTINGS.ball.size,
  }
end

-- ball's gameplay code
function Ball:update(racket_1: *Racket, racket_2: *Racket)
  self.pos = self.pos + self.direction * SETTINGS.ball.velocity

  -- does intersected limits?
  local on_left_side <const> = self.pos.x < 0
  local on_right_side <const> = self.pos.x + SETTINGS.ball.size > SETTINGS.winsize.x
  local on_up_side <const> = self.pos.y < 0
  local on_down_side <const> = self.pos.y + SETTINGS.ball.size > SETTINGS.winsize.y

  -- invert horizontal direction when intersecting left or right side and add points to the winner player
  if on_left_side or on_right_side then
    self.direction.x = -self.direction.x
    local winner_racket = on_left_side and racket_2 or racket_1
    winner_racket.points = winner_racket.points + 1
  end

  -- invert vertical direction when intersecting up or down side
  if on_down_side or on_up_side then
    self.direction.y = -self.direction.y
  end

  local ball_rect = self:get_rect()

  -- invert horizontal direction when intersecting rackets
  local r1_rect, r2_rect = racket_1:get_rect(true), racket_2:get_rect(false)
  local is_r1_intersecting, is_r2_intersecting = ball_rect:is_rect_intersecting(r1_rect), ball_rect:is_rect_intersecting(r2_rect)

  if is_r1_intersecting or is_r2_intersecting then
    self.direction.x = -self.direction.x
    self.pos.x = is_r1_intersecting and r1_rect.x + r1_rect.w or r2_rect.x - SETTINGS.ball.size
  end
end

function Ball:draw(nene_core: Nene.Core)
  nene_core:render_draw_rect(self:get_rect(), false, Nene.Palette.white)
end

local function update_points(nene_core: Nene.Core, pts_text: *TextTexture, points: integer, font: Nene.Font)
  local pts_str = tostring(points)
  defer pts_str:destroy() end
  pts_text:update_text(nene_core, pts_str, Nene.Palette.white, font)
end

local function game()
  -- nene setup:
  -- nene core initialization
  -- this example will use `Nene.Core` directly instead of `Nene.Main` since only simple feature will be used.
  local ok, nene_core = Nene.Core.init('nene pong example', SETTINGS.winsize.x, SETTINGS.winsize.y)
  assert(ok, 'core state initialization failed')
  defer nene_core:terminate() end

  -- game setup:
  local pl_1: Racket, pl_2: Racket, ball = {}, {}, Ball.new()
  local font = Nene.Font.load('resources/monogram_extended.ttf', 72)
  defer font:destroy() end

  local r1_text, r2_text = TextTexture.new(nene_core, '0', Nene.Palette.white, font),
                           TextTexture.new(nene_core, '0', Nene.Palette.white, font)
  defer
    r1_text:destroy()
    r2_text:destroy()
  end

  -- game loop:
  repeat
    nene_core:pool_events()

    do -- update step
      local prev_r1_points, prev_r2_points = pl_1.points, pl_2.points

      pl_1:update(nene_core, true)
      pl_2:update(nene_core, false)
      ball:update(pl_1, pl_2)

      if prev_r1_points ~= pl_1.points then
        update_points(nene_core, r1_text, pl_1.points, font)
      end
      if prev_r2_points ~= pl_2.points then
        update_points(nene_core, r2_text, pl_2.points, font)
      end
    end

    do -- draw step
      -- draw background
      nene_core:render_clear(Nene.Palette.bg)

      -- draw rackets and ball
      pl_1:draw(nene_core, true)
      pl_2:draw(nene_core, false)
      ball:draw(nene_core)

      -- draw points texts
      r1_text:draw(nene_core, {10, 0}, Nene.Palette.white)
      r2_text:draw(nene_core, {SETTINGS.winsize.x - r1_text.texture.width - 10, 0}, Nene.Palette.white)

      -- present the "drawing result"
      nene_core:render_present()
    end
  until nene_core.quit
end

game()
