--[[
Copyright (c) 2021-present Andr√© Luiz Alvares
Nene is licensed under the Zlib license.
Please refer to the LICENSE file for details
SPDX-License-Identifier: Zlib
]]

-- basic pong example! --

-- require basic libraries
local math = require 'math'
local string = require 'string'

-- require nene librarise and modules
local Nene = require 'nene'
local Color = require 'nene.color'
local Rect = require 'nene.math.rect'
local Vec2 = require 'nene.math.vec2'
local Vec2i = require 'nene.math.vec2i'

local Font = require 'nene.font'
local Texture = require 'nene.texture'
local TextTexture = require 'nene.text_texture'

-- general game settings
local SETTINGS: record{
  screen_size: Vec2i,
  win_size: Vec2i,
  racket: record{
    size: Vec2i,
    velocity: integer,
  },
  ball: record{
    size: integer,
    velocity: integer,
  }
} <const> = {
  screen_size = { 400, 240 },
  win_size = { (400*2), (240*2) },
  racket = {
    size = { 20, 100 },
    velocity = 120,
  },
  ball = {
    size = 10,
    velocity = 150,
  }
}

-- pong code:

-- racket record
local Racket = @record{
  pos_y: number,
  points: integer,
}

-- return the rect of the racket
function Racket:get_rect(is_player_one: boolean): Rect
  return Rect{
    pos = { 
      x = (is_player_one and 20 or SETTINGS.screen_size.x - SETTINGS.racket.size.x - 20), 
      y = self.pos_y,
    },
    size = SETTINGS.racket.size,
  }
end

-- racket's gameplay code
function Racket:update(is_player_one: boolean <comptime>)
  local nene = Nene.instance()

  -- input
  local is_up, is_down = false, false

  ## if is_player_one.value then
    is_up, is_down = nene:get_scancode(Nene.Scancode.W), nene:get_scancode(Nene.Scancode.S)
  ## else
    is_up, is_down = nene:get_scancode(Nene.Scancode.I), nene:get_scancode(Nene.Scancode.K)
  ## end

  -- movement
  local ylimit <const> = SETTINGS.screen_size.y - SETTINGS.racket.size.y

  if is_up then
    self.pos_y = math.clamp(self.pos_y - SETTINGS.racket.velocity * nene.delta_time, 0, ylimit)
  end

  if is_down then
    self.pos_y = math.clamp(self.pos_y + SETTINGS.racket.velocity * nene.delta_time, 0, ylimit)
  end
end

-- draw a racket
function Racket:draw(is_player_one: boolean)
  local nene = Nene.instance()
  nene:render_draw_rect(self:get_rect(is_player_one), false, Color.Palette.yellow)
end

-- ball record
local Ball = @record{
  pos: Vec2,
  direction: Vec2,
}

-- return the ball's rect
function Ball:get_rect(): Rect
  return Rect{
    pos = Vec2.to_Vec2i(self.pos), 
    size = Vec2i.one() * SETTINGS.ball.size,
  }
end

-- ball's gameplay code
function Ball:update(racket_1: *Racket, racket_2: *Racket, delta_time: number)
  self.pos = self.pos + self.direction * SETTINGS.ball.velocity * delta_time

  -- does intersected limits?
  local on_left_side  <const> = self.pos.x < 0
  local on_right_side <const> = self.pos.x + SETTINGS.ball.size > SETTINGS.screen_size.x
  local on_up_side    <const> = self.pos.y < 0
  local on_down_side  <const> = self.pos.y + SETTINGS.ball.size > SETTINGS.screen_size.y

  -- invert horizontal direction when intersecting left or right side and add points to the winner player
  -- also resets ball position to center
  if on_left_side or on_right_side then
    self.direction.x = -self.direction.x
    local winner_racket = on_left_side and racket_2 or racket_1
    winner_racket.points = winner_racket.points + 1
    self.pos = { SETTINGS.screen_size.x // 2, SETTINGS.screen_size.y // 2 }
  end

  -- invert vertical direction when intersecting up or down side
  if on_down_side and self.direction.y > 0 or on_up_side and self.direction.y < 0 then
    self.direction.y = -self.direction.y
  end

  -- invert horizontal direction when intersecting rackets
  local ball_rect = self:get_rect()
  local r1_rect, r2_rect = racket_1:get_rect(true), racket_2:get_rect(false)

  local r1_intersected, r2_intersected = ball_rect:is_rect_intersecting(r1_rect),
                                           ball_rect:is_rect_intersecting(r2_rect)

  if r1_intersected or r2_intersected then
    self.direction.x = -self.direction.x
    self.pos.x = r1_intersected and r1_rect.pos.x + r1_rect.size.x or r2_rect.pos.x - SETTINGS.ball.size
  end
end

function Ball:draw(nene: Nene)
  nene:render_draw_rect(self:get_rect(), false)
end

local function update_points(pts_text: *TextTexture, points: integer, font: Font)
  local pts_str <close> = tostring(points)
  pts_text:update_text(pts_str, font)
end

local function game()
  -- nene setup --

  -- nene initialization and to-be-closed termination
  --
  -- when nene is marked with the <close> annotation, then the nene variable becomes
  -- a "to-be-closed" variable, this means that the `__close` method will be called at the end scope,
  -- `_cllose` calls the `terminate` method, which de-initializes nene and free the internal resources
  local ok, nene <close> = Nene.init('nene pong', SETTINGS.win_size.x, SETTINGS.win_size.y)
  assert(ok, 'nene initialization failed')

  -- game setup --

  -- this creates a new "Nene Texture" which will be used as low resolution
  -- screen through using render target (sometimes called as Render Texture on some engines),
  -- due to this, it will use "target" texture access.
  --
  -- note that the value comes from SDL directly, while Nene abstracts SDL many
  -- times, it doesn't try to hide it, so you will interact with SDL sometimes,
  -- especially to go beyond Nene capabilities if needed.
  local ok, screen <close> = Texture.create_texture(SETTINGS.screen_size.x, SETTINGS.screen_size.y, nil, Texture.Access.Target)
  assert(ok, 'could not create the screen texture target')

  -- creates players rackets and the ball
  local pl_1: Racket, pl_2: Racket;
  local ball: Ball = {
    pos = { SETTINGS.screen_size.x // 2, SETTINGS.screen_size.y // 2 },
    direction = { 1, 1 },
  }

  -- "monogram_extended" font is available with nene, but it's not loaded automatically.
  local ok, font <close> = Font.load('resources/monogram_extended.ttf', 72)
  assert(ok, 'could not load monogram_extended font')

  -- creates both players texts and then defer it's destroy calls
  local r1_text <close>, r2_text <close> = TextTexture.init('0', font), TextTexture.init('0', font)

  -- finally, the game loop
  -- In Nene, you just `repeat` the loop until Nene gets a "quit" state
  -- this happens when the game is just to be closed.
  repeat
    -- this updates the internal state, it also polls all the SDL events,
    -- you can pass many callbacks to react to these events.
    nene:poll_events()

    -- update step
    do
      local prev_r1_points, prev_r2_points = pl_1.points, pl_2.points

      pl_1:update(true)
      pl_2:update(false)
      ball:update(pl_1, pl_2, nene.delta_time)

      if prev_r1_points ~= pl_1.points then
        update_points(r1_text, pl_1.points, font)
      end
      if prev_r2_points ~= pl_2.points then
        update_points(r2_text, pl_2.points, font)
      end
    end

    -- draw step
    do
      -- set a low-resolution screen as the render target, this is very useful to make pixel-art games.
      nene:set_render_target(screen:get_raw())

      -- clear screen, otherwise the game would draw frame on top of previous frames,
      -- which gives weird results.
      nene:render_clear(Color.Palette.bg)

      -- rendering on the screen
      do
        -- draw rackets and ball
        pl_1:draw(true)
        pl_2:draw(false)
        ball:draw(nene)

        -- draw points texts
        r1_text:draw({10, 0})
        r2_text:draw({SETTINGS.screen_size.x - r1_text.texture.width - 10, 0})
      end

      -- reset render target to window screen, this is the default when no render target is used.
      nene:set_render_target(nilptr)

      -- draw the whole screen on the whole window screen.
      screen:draw()

      -- present the "drawing result".
      -- In SDL (and consequently Nene) applies all draw operations on a backbuffer, this is very
      -- common in many game libraries.
      -- render_present presents the composed backbuffer on the screen.
      nene:render_present()
    end
  until nene.quit -- this loop will be repeated until Nene assign `true` to `Nene.quit` variable.

  -- all the memory  will be released due the defer blocks above.
end

-- the code is inside a function, here we call it.
-- this is not mandatory in Nene, you can just write the code here too,
-- however, coding in a function is required to make address sanitizer
-- (a memory debug utility) work as expected.
game()
