require 'math'
require 'string'

-- you can require each nene module individually,
-- here, we are requiring all modules at once for the sake of simplicity
require 'nene'

-- basic pong example!
-- this one will use `Nene.Core` instead of `Nene.Main` since no resources (like textures and sounds) will be used.
local Rect, Vec2, TextTexture = Nene.Math.Rect, Nene.Math.Vec2, Nene.TextTexture

-- general game settings
local SETTINGS: record{
  winsize: Vec2,
  racket: record{
    size: Vec2,
    velocity: integer,
  },
  ball: record{
    size: integer,
    velocity: integer,
  }
} <const> = {
  winsize = { 640, 360 },
  racket = {
    size = { 20, 100 },
    velocity = 4,
  },
  ball = {
    size = 10,
    velocity = 5,
  }
}

-- nene core initialization
local ok, nene_core = Nene.Core.init('nene pong example', SETTINGS.winsize.x, SETTINGS.winsize.y)
assert(ok, 'core state initialization failed')

-- pong code:

-- racket record
local Racket = @record{
  pos_y: integer,
  points: integer,
}

-- return the rect of the racket
function Racket:get_rect(is_player_one: boolean): Rect
  return (@Rect){
    x = math.ifloor(is_player_one and 20 or SETTINGS.winsize.x - SETTINGS.racket.size.x - 20),
    y = self.pos_y,
    w = SETTINGS.racket.size.x, h = SETTINGS.racket.size.y
  }
end

-- racket's gameplay code
function Racket:update(is_player_one: boolean <comptime>)
  -- input
  local is_up, is_down = false, false

  ## if is_player_one.value then
    is_up, is_down = nene_core:get_scancode(SDL_SCANCODE_W), nene_core:get_scancode(SDL_SCANCODE_S)
  ## else
    is_up, is_down = nene_core:get_scancode(SDL_SCANCODE_I), nene_core:get_scancode(SDL_SCANCODE_K)
  ## end

  -- movement
  local ylimit <const> = SETTINGS.winsize.y - SETTINGS.racket.size.y
  if is_up then
    self.pos_y = math.clamp(self.pos_y - SETTINGS.racket.velocity, 0, ylimit)
  end
  if is_down then
    self.pos_y = math.clamp(self.pos_y + SETTINGS.racket.velocity, 0, ylimit)
  end
end

-- draw a racket
function Racket:draw(is_player_one: boolean)
  nene_core:render_draw_rect(self:get_rect(is_player_one), false, Nene.Palette.yellow)
end

-- ball record
local Ball = @record{
  pos: Vec2,
  direction: Vec2,
}

function Ball.new()
  return (@Ball){
    pos = { SETTINGS.winsize.x // 2, SETTINGS.winsize.y // 2 },
    direction = { 1, 1 },
  }
end

-- return the ball's rect
function Ball:get_rect(): Rect
  return (@Rect){
    x = self.pos.x, y = self.pos.y,
    w = SETTINGS.ball.size, h = SETTINGS.ball.size,
  }
end

-- ball's gameplay code
function Ball:update(racket_1: Racket, racket_2: Racket)
  self.pos = self.pos + self.direction * SETTINGS.ball.velocity

  -- does intersected limits?
  local on_left_side <const> = self.pos.x < 0
  local on_right_side <const> = self.pos.x + SETTINGS.ball.size > SETTINGS.winsize.x
  local on_up_side <const> = self.pos.y < 0
  local on_down_side <const> = self.pos.y + SETTINGS.ball.size > SETTINGS.winsize.y

  -- invert horizontal direction when intersecting left or right side and add points to the winner player
  if on_left_side or on_right_side then
    self.direction.x = -self.direction.x

    if on_left_side then
      racket_2.points = racket_2.points + 1
    else
      racket_1.points = racket_1.points + 1
    end
  end

  -- invert vertical direction when intersecting up or down side
  if on_down_side or on_up_side then
    self.direction.y = -self.direction.y
  end

  local ball_rect = self:get_rect()

  -- invert horizontal direction when intersecting rackets
  local r1_rect, r2_rect = racket_1:get_rect(true), racket_2:get_rect(false)
  local is_r1_intersecting, is_r2_intersecting = ball_rect:is_rect_intersecting(r1_rect), ball_rect:is_rect_intersecting(r2_rect)

  if is_r1_intersecting or is_r2_intersecting then
    self.direction.x = -self.direction.x
    self.pos.x = is_r1_intersecting and r1_rect.x + r1_rect.w or r2_rect.x - SETTINGS.ball.size
  end
end

function Ball:draw()
  nene_core:render_draw_rect(self:get_rect(), false, Nene.Palette.white)
end

-- local function update_points(pts_text: *TextTexture, points: integer)
--   local pts_str = tostring(points)
--   defer pts_str:destroy() end
--   pts_text:update_text(pts_str, Nene.Palette.white)
-- end

-- setup:
local pl_1: Racket, pl_2: Racket, ball = {}, {}, Ball.new()
--local r1_text, r2_text = TextTexture.new(nene_core, '0', Nene.Palette.white),
--                         TextTexture.new(nene_core, '0', Nene.Palette.white)

-- game loop:
repeat
  nene_core:pool_events()

  do -- update step
    local r1_pts_before, r2_pts_before = pl_1.points, pl_2.points

    ball:update(pl_1, pl_2)
    pl_1:update(true)
    pl_2:update(false)

    -- if r1_pts_before ~= pl_1.points then
    --   update_points(r1_text, pl_1.points)
    -- end
    -- if r2_pts_before ~= pl_2.points then
    --   update_points(r2_text, pl_2.points)
    -- end
  end

  do -- draw step
    nene_core:render_clear(Nene.Palette.bg)

    pl_1:draw(true)
    pl_2:draw(false)
    ball:draw()

    --r1_text:draw(nene_core, {10, 0}, Nene.Palette.white)
    --r2_text:draw(nene_core, {SETTINGS.winsize.x - r1_text.texture.width - 10, 0}, Nene.Palette.white)

    nene_core:render_present()
  end
until nene_core.quit
