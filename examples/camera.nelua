--[[
Copyright (c) 2021-present Andr√© Luiz Alvares
Nene is licensed under the Zlib license.
Please refer to the LICENSE file for details
SPDX-License-Identifier: Zlib
]]

-- In this demo, is presented a basic camera control
--
-- Actually, there is no "camera" on Nene, instead, there is a
-- `Vec2` offset done in all rendering calls, this offset is the
-- `render_offset` field.

-- You can modify this field in order to add a basic camera control.

local Nene = require 'nene'
local Color = require 'nene.color'
local Rect = require 'nene.math.rect'

-- In this example it also be showcased how to split your game logic into multiple functions.
--
-- It's pretty simple, you can use `Nene.instance()` to get the Nene instance on the
-- function body, this is called "singleton".
--
-- For better safety, it's always checked if Nene is initialized when calling this
-- function on non-release builds (unless you set the `nochecks` pragma)
local function draw_parallax_grid()
  -- let's draw a grid with parallax effect! --

  -- get the running nene instance
  local nene = Nene.instance()

  -- save our original render_offset value
  local original_offset = nene.render_offset

  -- multiply render_offset by half, this is what makes the parallax effect
  nene.render_offset = nene.render_offset * 0.5

  -- draw the grid
  for i = -64, 64 do
    nene:render_draw_line({16 * i, -2048}, {16 * i, 2048}, Color.Palette.black)
    nene:render_draw_line({-2048, 16 * i}, {2048, 16 * i}, Color.Palette.black)
  end

  -- at the end of the function, we set the render_offset to the original value
  nene.render_offset = original_offset
end

local function draw_parallax_shadow()
  -- same logic as draw_parallax_grid --

  local nene = Nene.instance()

  local original_offset = nene.render_offset
  nene.render_offset = nene.render_offset * 0.5

  -- we can also use defer, so this statement is done at the end of the function
  -- see more here: https://nelua.io/overview/#defer
  defer nene.render_offset = original_offset end

  nene:render_draw_rect({120, 120, 16, 16}, false, {0, 0, 0, 100})
end

-- all the life-cycle of this example is contained in this function
local function camera()
  -- initialize and test nene initialization and defer it's termination using a to-be-closed variable.
  --
  -- When nene is initialized, you get an ok status which should be asserted
  -- and a nene instance, when the nene instance is initialized, the ok status is
  -- `true`, otherwise, it's `false` and the nene instance contains only zeroed data.
  local ok, nene <close> = Nene.init('nene basic camera', 256, 256)
  assert(ok, 'error: nene initialization failed')

  -- create a rect
  local rect_on_center: Rect = {112, 112, 32, 32}

  repeat
    -- update logic --

    -- update nene state
    nene:poll_events()

    -- modify `render_offset` field in order to get a basic camera control --
    if nene:get_scancode(Nene.Scancode.Right) then
      nene.render_offset.x = nene.render_offset.x - 1
    elseif nene:get_scancode(Nene.Scancode.Left) then
      nene.render_offset.x = nene.render_offset.x + 1
    end

    if nene:get_scancode(Nene.Scancode.Up) then
      nene.render_offset.y = nene.render_offset.y + 1
    elseif nene:get_scancode(Nene.Scancode.Down) then
      nene.render_offset.y = nene.render_offset.y - 1
    end

    -- rendering logic --

    nene:render_clear(Color.Palette.bg)
    do
      draw_parallax_grid()
      draw_parallax_shadow()

      -- draw the rect, note that rect_on_center is never modified
      nene:render_draw_rect(rect_on_center, false)
    end

    nene:render_present()
  until nene.quit

  -- since `nene` it's a to-be-closed variable, it will terminated here in the end scope --
end

-- run example
camera()
