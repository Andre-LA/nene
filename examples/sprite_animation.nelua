-- Copyright (c) 2021-2022 Andr√© Luiz Alvares
-- Nene is licensed under the Zlib license.
-- Please refer to the LICENSE file for details
-- SPDX-License-Identifier: Zlib

-- This example presents how to use the texture atlas module and using some more advanced texture drawing

local math = require 'math'

local Nene = require 'nene'
local Color = require 'nene.color'
local Texture = require 'nene.texture'
local TextureAtlas = require 'nene.texture_atlas'

--[[
Here all the game code is inside a "game" function because it make address sanitizer more detailed.
In your games, you may use a "game frame" function, this makes web port easier.
Since a web port is beyond this example, using just a "game" function is enough.
]]
local function game()
  -- initialize nene and test if got succesfully initialized
  local ok, nene <close> = Nene.init('nene sprite animation', (64*4), (64*4))
  assert(ok, 'error: nene initialization failed')

  -- rotation parameter, it'll be increased over time
  local rotation = 0.0

  --[[
  Create a texture atlas with img_shapes.png image on it,
  then test initialization and defers it's destruction using to-be-closed variable
  note that img_shapes images contains four shapes, on a 32x32 alignment.

  More details can be read on the texture_atlas example.
  ]]
  local ok, spritesheet <close> = TextureAtlas.load('resources/img_shapes.png', 2, { cell_size = { 32, 32} })
  assert(ok, "error: 'img_shapes.png' could not be loaded")

  --[[
  Let's create a timer, this will store the time just after SDL (nene) initialization.
  this variable will only be modified when the sprite changes.
  ]]
  local prev_time = nene.current_time

  --[[
  The sprite index which we want to render on the current frame, this
  refers to the sub-sprite of the spritesheet, the first one is on top-left,
  the last is on bottom-right, the flow is left-to-right, up-to-down.
  ]]
  local sprite_index = 0

  -- with everything setup, now we run our game loop until the game will quit
  repeat
    -- updates the nene internal state
    nene:poll_events()

    -- increase rotation over time
    rotation = nene.current_time * 0.01

    --[[
    If the difference between the last time we changed the sprite and now
    is greater than one second, then we updates prev_time and change
    the sprite index used on spritesheet rendering.
    ]]
    if nene.current_time - prev_time > 1000 then
      prev_time = nene.current_time
      sprite_index = (sprite_index + 1) % 4
    end

    -- let's draw our game, first we need to clear the backbuffer.
    nene:render_clear()

    --[[
    Then, draw the sprite from the spritesheet at {10, 10} position, using
    the spritesheet texture atlas, using the sprite index.
    ]]
    spritesheet:draw_nth_sub_texture(sprite_index, { 10, 10 },  nil, rotation)

    -- finally, swap buffers and present our final result
    nene:render_present()
  until nene.quit
end

-- run the game
game()
